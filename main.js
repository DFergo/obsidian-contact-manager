/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ContactCardsPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian6 = require("obsidian");

// src/contact-types.ts
var DEFAULT_SETTINGS = {
  enabledContactTypes: ["People", "Company", "TradeUnion", "Organization"],
  peopleFolders: ["People"],
  companyFolders: ["Companies"],
  tradeUnionFolders: ["TradeUnions"],
  organizationFolders: ["Organizations"],
  peopleTemplate: `---
aliases: []
collections:
company:
country:
coverImage:
description:
email:
lastUpdated:
linkedin:
organization:
phone:
role:
tags:
title:
tradeUnion:
type: People
related: []
---

## Contact Card

## Notes

`,
  companyTemplate: `---
type: Company
coverImage:
description:
lastUpdated:
activeProjects:
contactInfo:
coordinator:
website:
folder:
management:
tags:
country:
collections:
title:
aliases: []
related: []
---

## Contact Card

## Notes

`,
  tradeUnionTemplate: `---
aliases: []
activeProjects:
collections:
contactInfo:
country:
description:
folder:
lastUpdated:
coverImage:
people:
tags:
title:
type: TradeUnion
website:
related: []
---

## Contact Card

## Notes

`,
  organizationTemplate: `---
activeProjects:
aliases: []
collections:
contactInfo:
country:
coverImage:
description:
folder:
lastUpdated:
people:
tags:
title:
type: Organization
website:
related: []
---

## Contact Card

## Notes

`
};

// src/settings-tab.ts
var import_obsidian = require("obsidian");
var ContactCardsSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.allFolders = [];
    this.plugin = plugin;
    this.getAllFolders();
  }
  getAllFolders() {
    const folderSet = /* @__PURE__ */ new Set();
    const addFolder = (folder) => {
      folderSet.add(folder.path);
      folder.children.forEach((child) => {
        if (child instanceof import_obsidian.TFolder) {
          addFolder(child);
        }
      });
    };
    this.app.vault.getAllLoadedFiles().forEach((file) => {
      if (file instanceof import_obsidian.TFolder) {
        addFolder(file);
      }
    });
    this.allFolders = Array.from(folderSet).sort();
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "ContactManager Settings" });
    this.addInstructionsSection();
    containerEl.createEl("h3", { text: "Enabled Contact Types" });
    containerEl.createEl("p", {
      text: "Select which contact types you want to use. Disabled types won't appear in menus or settings.",
      cls: "setting-item-description"
    });
    this.addContactTypeToggle("People", "Always enabled - required for the plugin to function");
    this.addContactTypeToggle("Company", "Companies and organizations");
    this.addContactTypeToggle("TradeUnion", "Trade unions and labor organizations");
    this.addContactTypeToggle("Organization", "General organizations and institutions");
    containerEl.createEl("h3", { text: "Folder Configuration" });
    containerEl.createEl("p", {
      text: "Configure which folders contain each type of contact. Use the + button to add multiple folders.",
      cls: "setting-item-description"
    });
    if (this.plugin.settings.enabledContactTypes.includes("People")) {
      this.addMultipleFolderSetting(
        "People Folders",
        "peopleFolders",
        "Folders containing People contacts"
      );
    }
    if (this.plugin.settings.enabledContactTypes.includes("Company")) {
      this.addMultipleFolderSetting(
        "Company Folders",
        "companyFolders",
        "Folders containing Company contacts"
      );
    }
    if (this.plugin.settings.enabledContactTypes.includes("TradeUnion")) {
      this.addMultipleFolderSetting(
        "Trade Union Folders",
        "tradeUnionFolders",
        "Folders containing Trade Union contacts"
      );
    }
    if (this.plugin.settings.enabledContactTypes.includes("Organization")) {
      this.addMultipleFolderSetting(
        "Organization Folders",
        "organizationFolders",
        "Folders containing Organization contacts"
      );
    }
    containerEl.createEl("h3", { text: "Templates" });
    containerEl.createEl("p", {
      text: "Templates used when creating new contacts. Use {{title}} for the contact name and {{date}} for the current date.",
      cls: "setting-item-description"
    });
    if (this.plugin.settings.enabledContactTypes.includes("People")) {
      this.addTemplateSetting("People Template", "peopleTemplate");
    }
    if (this.plugin.settings.enabledContactTypes.includes("Company")) {
      this.addTemplateSetting("Company Template", "companyTemplate");
    }
    if (this.plugin.settings.enabledContactTypes.includes("TradeUnion")) {
      this.addTemplateSetting("Trade Union Template", "tradeUnionTemplate");
    }
    if (this.plugin.settings.enabledContactTypes.includes("Organization")) {
      this.addTemplateSetting("Organization Template", "organizationTemplate");
    }
  }
  createAutocompleteInput(container, placeholder, initialValue, onChangeCallback) {
    const inputContainer = container.createDiv({ cls: "autocomplete-container" });
    const input = inputContainer.createEl("input", {
      type: "text",
      placeholder,
      value: initialValue,
      cls: "autocomplete-input"
    });
    const suggestionsList = inputContainer.createDiv({ cls: "autocomplete-suggestions" });
    suggestionsList.style.display = "none";
    let selectedIndex = -1;
    const showSuggestions = (query) => {
      const filtered = Array.from(new Set(
        this.allFolders.filter(
          (folder) => folder.toLowerCase().includes(query.toLowerCase()) && folder !== query
        )
      )).slice(0, 8);
      suggestionsList.empty();
      if (filtered.length === 0) {
        suggestionsList.style.display = "none";
        return;
      }
      filtered.forEach((folder, index) => {
        const suggestion = suggestionsList.createDiv({
          text: folder,
          cls: "autocomplete-suggestion"
        });
        suggestion.addEventListener("click", () => {
          input.value = folder;
          suggestionsList.style.display = "none";
          onChangeCallback(folder);
        });
        if (index === selectedIndex) {
          suggestion.addClass("selected");
        }
      });
      suggestionsList.style.display = "block";
    };
    input.addEventListener("input", (e) => {
      const value = e.target.value;
      selectedIndex = -1;
      if (value.length > 0) {
        showSuggestions(value);
      } else {
        suggestionsList.style.display = "none";
      }
      onChangeCallback(value);
    });
    input.addEventListener("keydown", (e) => {
      const suggestions = suggestionsList.querySelectorAll(".autocomplete-suggestion");
      if (e.key === "ArrowDown") {
        e.preventDefault();
        selectedIndex = Math.min(selectedIndex + 1, suggestions.length - 1);
        updateSelection();
      } else if (e.key === "ArrowUp") {
        e.preventDefault();
        selectedIndex = Math.max(selectedIndex - 1, -1);
        updateSelection();
      } else if (e.key === "Enter" && selectedIndex >= 0) {
        e.preventDefault();
        const selectedSuggestion = suggestions[selectedIndex];
        input.value = selectedSuggestion.textContent || "";
        suggestionsList.style.display = "none";
        onChangeCallback(input.value);
      } else if (e.key === "Escape") {
        suggestionsList.style.display = "none";
        selectedIndex = -1;
      }
    });
    const updateSelection = () => {
      const suggestions = suggestionsList.querySelectorAll(".autocomplete-suggestion");
      suggestions.forEach((suggestion, index) => {
        if (index === selectedIndex) {
          suggestion.addClass("selected");
        } else {
          suggestion.removeClass("selected");
        }
      });
    };
    input.addEventListener("blur", (e) => {
      setTimeout(() => {
        suggestionsList.style.display = "none";
      }, 150);
    });
    return input;
  }
  addSingleFolderSetting(name, settingKey, description) {
    const setting = new import_obsidian.Setting(this.containerEl).setName(name).setDesc(description || `Configure ${name.toLowerCase()}`);
    const currentValue = this.plugin.settings[settingKey];
    this.createAutocompleteInput(
      setting.controlEl,
      "Folder path",
      currentValue,
      async (value) => {
        this.plugin.settings[settingKey] = value;
        await this.plugin.saveSettings();
      }
    );
  }
  addMultipleFolderSetting(name, settingKey, description) {
    const setting = new import_obsidian.Setting(this.containerEl).setName(name).setDesc(description || `Configure ${name.toLowerCase()}`);
    const foldersContainer = setting.controlEl.createDiv({ cls: "multiple-folders-container" });
    const renderFolders = () => {
      foldersContainer.empty();
      const currentFolders = this.plugin.settings[settingKey];
      currentFolders.forEach((folder, index) => {
        const folderRow = foldersContainer.createDiv({ cls: "folder-row" });
        this.createAutocompleteInput(
          folderRow,
          "Folder path",
          folder,
          async (value) => {
            const freshFolders = [...this.plugin.settings[settingKey]];
            freshFolders[index] = value;
            this.plugin.settings[settingKey] = freshFolders;
            await this.plugin.saveSettings();
          }
        );
        const removeButton = folderRow.createEl("button", {
          text: "\u2212",
          cls: "folder-remove-button"
        });
        removeButton.addEventListener("click", async () => {
          const freshFolders = [...this.plugin.settings[settingKey]];
          freshFolders.splice(index, 1);
          this.plugin.settings[settingKey] = freshFolders;
          await this.plugin.saveSettings();
          renderFolders();
        });
      });
      const addButton = foldersContainer.createEl("button", {
        text: "+ Add Folder",
        cls: "folder-add-button"
      });
      addButton.addEventListener("click", async () => {
        const freshFolders = [...this.plugin.settings[settingKey]];
        freshFolders.push("");
        this.plugin.settings[settingKey] = freshFolders;
        await this.plugin.saveSettings();
        renderFolders();
      });
    };
    renderFolders();
  }
  addTemplateSetting(name, settingKey) {
    new import_obsidian.Setting(this.containerEl).setName(name).setDesc(`Template used when creating new ${name.toLowerCase().replace(" template", "")} contacts`).addTextArea((text) => {
      text.setPlaceholder("Template content with frontmatter").setValue(this.plugin.settings[settingKey]).onChange(async (value) => {
        this.plugin.settings[settingKey] = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.rows = 10;
      text.inputEl.cols = 50;
      return text;
    });
  }
  getFoldersForContactType(contactType) {
    switch (contactType) {
      case "People":
        return this.plugin.settings.peopleFolders;
      case "Company":
        return this.plugin.settings.companyFolders;
      case "TradeUnion":
        return this.plugin.settings.tradeUnionFolders;
      case "Organization":
        return this.plugin.settings.organizationFolders;
      default:
        return [];
    }
  }
  getTemplateForContactType(contactType) {
    switch (contactType) {
      case "People":
        return this.plugin.settings.peopleTemplate;
      case "Company":
        return this.plugin.settings.companyTemplate;
      case "TradeUnion":
        return this.plugin.settings.tradeUnionTemplate;
      case "Organization":
        return this.plugin.settings.organizationTemplate;
      default:
        return "";
    }
  }
  addContactTypeToggle(contactType, description) {
    const isEnabled = this.plugin.settings.enabledContactTypes.includes(contactType);
    const isPeopleType = contactType === "People";
    new import_obsidian.Setting(this.containerEl).setName(contactType).setDesc(description).addToggle((toggle) => {
      toggle.setValue(isEnabled).setDisabled(isPeopleType).onChange(async (value) => {
        if (isPeopleType)
          return;
        const enabledTypes = [...this.plugin.settings.enabledContactTypes];
        if (value && !enabledTypes.includes(contactType)) {
          enabledTypes.push(contactType);
        } else if (!value) {
          const index = enabledTypes.indexOf(contactType);
          if (index > -1) {
            enabledTypes.splice(index, 1);
          }
        }
        this.plugin.settings.enabledContactTypes = enabledTypes;
        await this.plugin.saveSettings();
        this.display();
      });
    });
  }
  addInstructionsSection() {
    const instructionsContainer = this.containerEl.createDiv({ cls: "instructions-section" });
    const instructionsHeader = instructionsContainer.createDiv({ cls: "instructions-header" });
    const toggleButton = instructionsHeader.createEl("button", {
      text: "\u{1F4D6} Plugin Instructions",
      cls: "instructions-toggle-button"
    });
    const instructionsContent = instructionsContainer.createDiv({
      cls: "instructions-content",
      attr: { style: "display: none;" }
    });
    const languageContainer = instructionsContent.createDiv({ cls: "language-selector" });
    languageContainer.createEl("label", { text: "Language: ", cls: "language-label" });
    const languageSelect = languageContainer.createEl("select", { cls: "language-select" });
    const languages = [
      { code: "en", name: "English" },
      { code: "es", name: "Espa\xF1ol" },
      { code: "fr", name: "Fran\xE7ais" },
      { code: "jp", name: "\u65E5\u672C\u8A9E" }
    ];
    languages.forEach((lang) => {
      languageSelect.createEl("option", {
        value: lang.code,
        text: lang.name
      });
    });
    const instructionsText = instructionsContent.createDiv({ cls: "instructions-text" });
    let isExpanded = false;
    toggleButton.addEventListener("click", () => {
      isExpanded = !isExpanded;
      instructionsContent.style.display = isExpanded ? "block" : "none";
      toggleButton.textContent = isExpanded ? "\u{1F4D6} Plugin Instructions \u25BC" : "\u{1F4D6} Plugin Instructions \u25BA";
      if (isExpanded) {
        this.updateInstructionsText(instructionsText, languageSelect.value);
      }
    });
    languageSelect.addEventListener("change", () => {
      this.updateInstructionsText(instructionsText, languageSelect.value);
    });
    this.updateInstructionsText(instructionsText, "en");
  }
  updateInstructionsText(container, language) {
    const instructions = this.getInstructions(language);
    container.innerHTML = instructions;
  }
  getInstructions(language) {
    const instructions = {
      en: `
                <h4>\u{1F3AF} What is ContactManager?</h4>
                <p>ContactManager helps you organize professional contacts, companies, trade unions, and organizations in your Obsidian vault with interactive contact cards and automatic relationship detection.</p>

                <h4>\u{1F50D} Contact Manager View</h4>
                <p>The main plugin interface (access via ribbon icon \u{1F465} or command palette) with:</p>
                <ul>
                    <li><strong>Browse:</strong> All contacts organized by type tabs</li>
                    <li><strong>Search:</strong> Real-time filtering across all contact properties</li>
                    <li><strong>Sort:</strong> Alphabetically or by organization</li>
                    <li><strong>Create Button:</strong> Quick contact creation from the view</li>
                    <li><strong>Navigation:</strong> Click any contact to open its file</li>
                </ul>

                <h4>\u{1F4C4} Contact Cards in Notes</h4>
                <p>Interactive cards that automatically appear in contact files, showing:</p>
                <ul>
                    <li><strong>Profile Information:</strong> Photo, name, role, contact details</li>
                    <li><strong>Relationships:</strong> Related contacts with color coding</li>
                    <li><strong>Management Hierarchy:</strong> People in management roles (green)</li>
                    <li><strong>Trade Union Members:</strong> Union representatives (red)</li>
                    <li><strong>Organization Members:</strong> Affiliated people (purple)</li>
                    <li><strong>Interactive Navigation:</strong> Click names to jump to related contacts</li>
                </ul>

                <h4>\u2699\uFE0F Initial Setup</h4>
                <p><strong>1. Enable Contact Types:</strong> Choose which types you need (People, Company, TradeUnion, Organization)</p>
                <p><strong>2. Configure Folders:</strong> Set folders where each contact type will be stored</p>
                <p><strong>3. Customize Templates:</strong> Adjust the default templates for each contact type if needed</p>

                <h4>\u{1F4DD} Creating Contacts</h4>
                <p><strong>Method 1:</strong> Use the "Create" button in Contact Manager view</p>
                <p><strong>Method 2:</strong> Command palette ("Create Contact")</p>
                <p><strong>Method 3:</strong> Right-click in file explorer and select "Create Contact"</p>
                <p>The plugin will guide you through selecting the type and entering basic information.</p>

                <h4>\u{1F4CB} Functional Properties by Contact Type</h4>
                <p><strong>People:</strong></p>
                <ul>
                    <li><strong>type:</strong> "People" (required)</li>
                    <li><strong>coverImage:</strong> Profile photo ([[ImageName.jpg]] or path/image.jpg)</li>
                    <li><strong>role:</strong> Job title - displayed on card</li>
                    <li><strong>email, phone:</strong> Contact information - displayed on card</li>
                    <li><strong>company:</strong> [[CompanyName]] - creates relationship link</li>
                    <li><strong>organization:</strong> [[OrganizationName]] - creates relationship link</li>
                    <li><strong>tradeUnion:</strong> [[UnionName]] - creates relationship link</li>
                    <li><strong>collections:</strong> ["TradeUnion"] - required for union member detection</li>
                </ul>

                <p><strong>Companies/Organizations/Trade Unions:</strong></p>
                <ul>
                    <li><strong>type:</strong> "Company"/"Organization"/"TradeUnion" (required)</li>
                    <li><strong>coverImage:</strong> Logo - displayed on card and as overlay on member cards</li>
                    <li><strong>website:</strong> URL - displayed as clickable link</li>
                    <li><strong>contactInfo:</strong> General contact details - displayed on card</li>
                    <li><strong>management:</strong> [["PersonName1", "PersonName2"]] - shows management section</li>
                    <li><strong>people:</strong> [["PersonName1", "PersonName2"]] - shows members section (Organizations/Unions)</li>
                </ul>

                <p><strong>Universal Properties:</strong></p>
                <ul>
                    <li><strong>description:</strong> Displayed in card description section</li>
                    <li><strong>tags:</strong> Obsidian tags for organization</li>
                    <li><strong>lastUpdated:</strong> Leave empty for automatic tracking</li>
                </ul>

                <h4>\u{1F517} How Relationships Work</h4>
                <p>The plugin automatically detects relationships when you:</p>
                <ul>
                    <li>Set a person's <strong>company</strong> property \u2192 Shows them in company's management/people</li>
                    <li>Add someone to <strong>management</strong> array \u2192 Shows management section on organization card</li>
                    <li>Set <strong>tradeUnion</strong> + collections: ["TradeUnion"] \u2192 Shows union membership</li>
                </ul>

                <h4>\u{1F4A1} Tips</h4>
                <ul>
                    <li>Use consistent naming for contact files</li>
                    <li>Add profile photos with coverImage property</li>
                    <li>Disable unused contact types to simplify interface</li>
                    <li>Use [[WikiLinks]] format for all contact references</li>
                </ul>
            `,
      es: `
                <h4>\u{1F3AF} \xBFQu\xE9 es ContactManager?</h4>
                <p>ContactManager te ayuda a organizar contactos profesionales, empresas, sindicatos y organizaciones en tu vault de Obsidian con tarjetas de contacto interactivas y detecci\xF3n autom\xE1tica de relaciones.</p>

                <h4>\u{1F50D} Vista Gestor de Contactos</h4>
                <p>La interfaz principal del plugin (acceso v\xEDa icono \u{1F465} o paleta de comandos) con:</p>
                <ul>
                    <li><strong>Explorar:</strong> Todos los contactos organizados en pesta\xF1as por tipo</li>
                    <li><strong>Buscar:</strong> Filtrado en tiempo real en todas las propiedades</li>
                    <li><strong>Ordenar:</strong> Alfab\xE9ticamente o por organizaci\xF3n</li>
                    <li><strong>Bot\xF3n Crear:</strong> Creaci\xF3n r\xE1pida de contactos desde la vista</li>
                    <li><strong>Navegaci\xF3n:</strong> Clic en cualquier contacto para abrir su archivo</li>
                </ul>

                <h4>\u{1F4C4} Tarjetas de Contacto en Notas</h4>
                <p>Tarjetas interactivas que aparecen autom\xE1ticamente en archivos de contacto, mostrando:</p>
                <ul>
                    <li><strong>Informaci\xF3n de Perfil:</strong> Foto, nombre, rol, detalles de contacto</li>
                    <li><strong>Relaciones:</strong> Contactos relacionados con c\xF3digo de colores</li>
                    <li><strong>Jerarqu\xEDa de Gesti\xF3n:</strong> Personas en roles de gesti\xF3n (verde)</li>
                    <li><strong>Miembros Sindicales:</strong> Representantes sindicales (rojo)</li>
                    <li><strong>Miembros de Organizaci\xF3n:</strong> Personas afiliadas (p\xFArpura)</li>
                    <li><strong>Navegaci\xF3n Interactiva:</strong> Haz clic en nombres para saltar a contactos relacionados</li>
                </ul>

                <h4>\u2699\uFE0F Configuraci\xF3n Inicial</h4>
                <p><strong>1. Habilitar Tipos de Contacto:</strong> Elige qu\xE9 tipos necesitas (Personas, Empresa, Sindicato, Organizaci\xF3n)</p>
                <p><strong>2. Configurar Carpetas:</strong> Define las carpetas donde se almacenar\xE1 cada tipo de contacto</p>
                <p><strong>3. Personalizar Plantillas:</strong> Ajusta las plantillas predeterminadas seg\xFAn necesites</p>

                <h4>\u{1F4DD} Crear Contactos</h4>
                <p><strong>M\xE9todo 1:</strong> Usa el bot\xF3n "Create" en la vista Gestor de Contactos</p>
                <p><strong>M\xE9todo 2:</strong> Paleta de comandos ("Create Contact")</p>
                <p><strong>M\xE9todo 3:</strong> Clic derecho en explorador de archivos y selecciona "Create Contact"</p>
                <p>El plugin te guiar\xE1 en la selecci\xF3n del tipo y entrada de informaci\xF3n b\xE1sica.</p>

                <h4>\u{1F4CB} Propiedades Funcionales por Tipo de Contacto</h4>
                <p><strong>Personas:</strong></p>
                <ul>
                    <li><strong>type:</strong> "People" (requerido)</li>
                    <li><strong>coverImage:</strong> Foto de perfil ([[NombreImagen.jpg]] o ruta/imagen.jpg)</li>
                    <li><strong>role:</strong> T\xEDtulo del trabajo - se muestra en la tarjeta</li>
                    <li><strong>email, phone:</strong> Informaci\xF3n de contacto - se muestra en la tarjeta</li>
                    <li><strong>company:</strong> [[NombreEmpresa]] - crea enlace de relaci\xF3n</li>
                    <li><strong>organization:</strong> [[NombreOrganizaci\xF3n]] - crea enlace de relaci\xF3n</li>
                    <li><strong>tradeUnion:</strong> [[NombreSindicato]] - crea enlace de relaci\xF3n</li>
                    <li><strong>collections:</strong> ["TradeUnion"] - requerido para detecci\xF3n de miembros sindicales</li>
                </ul>

                <p><strong>Empresas/Organizaciones/Sindicatos:</strong></p>
                <ul>
                    <li><strong>type:</strong> "Company"/"Organization"/"TradeUnion" (requerido)</li>
                    <li><strong>coverImage:</strong> Logo - se muestra en tarjeta y como overlay en tarjetas de miembros</li>
                    <li><strong>website:</strong> URL - se muestra como enlace clicable</li>
                    <li><strong>contactInfo:</strong> Detalles de contacto generales - se muestra en tarjeta</li>
                    <li><strong>management:</strong> [["NombrePersona1", "NombrePersona2"]] - muestra secci\xF3n de gesti\xF3n</li>
                    <li><strong>people:</strong> [["NombrePersona1", "NombrePersona2"]] - muestra secci\xF3n de miembros (Organizaciones/Sindicatos)</li>
                </ul>

                <p><strong>Propiedades Universales:</strong></p>
                <ul>
                    <li><strong>description:</strong> Se muestra en la secci\xF3n de descripci\xF3n de la tarjeta</li>
                    <li><strong>tags:</strong> Etiquetas de Obsidian para organizaci\xF3n</li>
                    <li><strong>lastUpdated:</strong> Dejar vac\xEDo para seguimiento autom\xE1tico</li>
                </ul>

                <h4>\u{1F517} C\xF3mo Funcionan las Relaciones</h4>
                <p>El plugin detecta autom\xE1ticamente relaciones cuando:</p>
                <ul>
                    <li>Estableces la propiedad <strong>company</strong> de una persona \u2192 La muestra en gesti\xF3n/personas de la empresa</li>
                    <li>A\xF1ades a alguien al array <strong>management</strong> \u2192 Muestra secci\xF3n de gesti\xF3n en la tarjeta de organizaci\xF3n</li>
                    <li>Estableces <strong>tradeUnion</strong> + collections: ["TradeUnion"] \u2192 Muestra membres\xEDa sindical</li>
                </ul>

                <h4>\u{1F4A1} Consejos</h4>
                <ul>
                    <li>Usa nombres consistentes para archivos de contactos</li>
                    <li>A\xF1ade fotos de perfil con la propiedad coverImage</li>
                    <li>Deshabilita tipos de contacto no utilizados para simplificar la interfaz</li>
                    <li>Usa formato [[WikiLinks]] para todas las referencias de contactos</li>
                </ul>
            `,
      fr: `
                <h4>\u{1F3AF} Qu'est-ce que ContactManager?</h4>
                <p>ContactManager vous aide \xE0 organiser les contacts professionnels, entreprises, syndicats et organisations dans votre coffre Obsidian avec des cartes de contact interactives et d\xE9tection automatique des relations.</p>

                <h4>\u{1F50D} Vue Gestionnaire de Contacts</h4>
                <p>L'interface principale du plugin (acc\xE8s via ic\xF4ne \u{1F465} ou palette de commandes) avec:</p>
                <ul>
                    <li><strong>Parcourir:</strong> Tous les contacts organis\xE9s en onglets par type</li>
                    <li><strong>Rechercher:</strong> Filtrage en temps r\xE9el sur toutes les propri\xE9t\xE9s</li>
                    <li><strong>Trier:</strong> Alphab\xE9tiquement ou par organisation</li>
                    <li><strong>Bouton Cr\xE9er:</strong> Cr\xE9ation rapide de contacts depuis la vue</li>
                    <li><strong>Navigation:</strong> Cliquez sur n'importe quel contact pour ouvrir son fichier</li>
                </ul>

                <h4>\u{1F4C4} Cartes de Contact dans les Notes</h4>
                <p>Cartes interactives qui apparaissent automatiquement dans les fichiers de contact, montrant:</p>
                <ul>
                    <li><strong>Informations de Profil:</strong> Photo, nom, r\xF4le, coordonn\xE9es</li>
                    <li><strong>Relations:</strong> Contacts li\xE9s avec codage couleur</li>
                    <li><strong>Hi\xE9rarchie de Gestion:</strong> Personnes en r\xF4les de gestion (vert)</li>
                    <li><strong>Membres Syndicaux:</strong> Repr\xE9sentants syndicaux (rouge)</li>
                    <li><strong>Membres d'Organisation:</strong> Personnes affili\xE9es (violet)</li>
                    <li><strong>Navigation Interactive:</strong> Cliquez sur les noms pour aller aux contacts li\xE9s</li>
                </ul>

                <h4>\u2699\uFE0F Configuration Initiale</h4>
                <p><strong>1. Activer les Types de Contact:</strong> Choisissez les types dont vous avez besoin (Personnes, Entreprise, Syndicat, Organisation)</p>
                <p><strong>2. Configurer les Dossiers:</strong> D\xE9finissez les dossiers o\xF9 chaque type de contact sera stock\xE9</p>
                <p><strong>3. Personnaliser les Mod\xE8les:</strong> Ajustez les mod\xE8les par d\xE9faut selon vos besoins</p>

                <h4>\u{1F4DD} Cr\xE9er des Contacts</h4>
                <p><strong>M\xE9thode 1:</strong> Utilisez le bouton "Create" dans la vue Gestionnaire de Contacts</p>
                <p><strong>M\xE9thode 2:</strong> Palette de commandes ("Create Contact")</p>
                <p><strong>M\xE9thode 3:</strong> Clic droit dans l'explorateur de fichiers et s\xE9lectionnez "Create Contact"</p>
                <p>Le plugin vous guidera dans la s\xE9lection du type et la saisie des informations de base.</p>

                <h4>\u{1F4CB} Propri\xE9t\xE9s Fonctionnelles par Type de Contact</h4>
                <p><strong>Personnes:</strong></p>
                <ul>
                    <li><strong>type:</strong> "People" (requis)</li>
                    <li><strong>coverImage:</strong> Photo de profil ([[NomImage.jpg]] ou chemin/image.jpg)</li>
                    <li><strong>role:</strong> Titre du poste - affich\xE9 sur la carte</li>
                    <li><strong>email, phone:</strong> Informations de contact - affich\xE9es sur la carte</li>
                    <li><strong>company:</strong> [[NomEntreprise]] - cr\xE9e un lien de relation</li>
                    <li><strong>organization:</strong> [[NomOrganisation]] - cr\xE9e un lien de relation</li>
                    <li><strong>tradeUnion:</strong> [[NomSyndicat]] - cr\xE9e un lien de relation</li>
                    <li><strong>collections:</strong> ["TradeUnion"] - requis pour la d\xE9tection de membres syndicaux</li>
                </ul>

                <p><strong>Entreprises/Organisations/Syndicats:</strong></p>
                <ul>
                    <li><strong>type:</strong> "Company"/"Organization"/"TradeUnion" (requis)</li>
                    <li><strong>coverImage:</strong> Logo - affich\xE9 sur la carte et comme overlay sur les cartes de membres</li>
                    <li><strong>website:</strong> URL - affich\xE9 comme lien cliquable</li>
                    <li><strong>contactInfo:</strong> Coordonn\xE9es g\xE9n\xE9rales - affich\xE9es sur la carte</li>
                    <li><strong>management:</strong> [["NomPersonne1", "NomPersonne2"]] - affiche section de gestion</li>
                    <li><strong>people:</strong> [["NomPersonne1", "NomPersonne2"]] - affiche section de membres (Organisations/Syndicats)</li>
                </ul>

                <p><strong>Propri\xE9t\xE9s Universelles:</strong></p>
                <ul>
                    <li><strong>description:</strong> Affich\xE9e dans la section description de la carte</li>
                    <li><strong>tags:</strong> \xC9tiquettes Obsidian pour organisation</li>
                    <li><strong>lastUpdated:</strong> Laisser vide pour suivi automatique</li>
                </ul>

                <h4>\u{1F517} Comment Fonctionnent les Relations</h4>
                <p>Le plugin d\xE9tecte automatiquement les relations quand vous:</p>
                <ul>
                    <li>D\xE9finissez la propri\xE9t\xE9 <strong>company</strong> d'une personne \u2192 L'affiche dans gestion/personnes de l'entreprise</li>
                    <li>Ajoutez quelqu'un au tableau <strong>management</strong> \u2192 Affiche section de gestion sur la carte d'organisation</li>
                    <li>D\xE9finissez <strong>tradeUnion</strong> + collections: ["TradeUnion"] \u2192 Affiche adh\xE9sion syndicale</li>
                </ul>

                <h4>\u{1F4A1} Conseils</h4>
                <ul>
                    <li>Utilisez des noms coh\xE9rents pour les fichiers de contact</li>
                    <li>Ajoutez des photos de profil avec la propri\xE9t\xE9 coverImage</li>
                    <li>D\xE9sactivez les types de contact inutilis\xE9s pour simplifier l'interface</li>
                    <li>Utilisez le format [[WikiLinks]] pour toutes les r\xE9f\xE9rences de contacts</li>
                </ul>
            `,
      jp: `
                <h4>\u{1F3AF} ContactManager\u3068\u306F\uFF1F</h4>
                <p>ContactManager\u306F\u3001Obsidian vault\u3067\u30D7\u30ED\u7528\u9023\u7D61\u5148\u3001\u4F1A\u793E\u3001\u52B4\u50CD\u7D44\u5408\u3001\u7D44\u7E54\u3092\u30A4\u30F3\u30BF\u30E9\u30AF\u30C6\u30A3\u30D6\u306A\u9023\u7D61\u5148\u30AB\u30FC\u30C9\u3068\u81EA\u52D5\u95A2\u4FC2\u691C\u51FA\u3067\u6574\u7406\u3059\u308B\u306E\u306B\u5F79\u7ACB\u3061\u307E\u3059\u3002</p>

                <h4>\u{1F50D} \u9023\u7D61\u5148\u7BA1\u7406\u30D3\u30E5\u30FC</h4>
                <p>\u30D7\u30E9\u30B0\u30A4\u30F3\u306E\u30E1\u30A4\u30F3\u30A4\u30F3\u30BF\u30FC\u30D5\u30A7\u30FC\u30B9\uFF08\u30EA\u30DC\u30F3\u30A2\u30A4\u30B3\u30F3\u{1F465}\u307E\u305F\u306F\u30B3\u30DE\u30F3\u30C9\u30D1\u30EC\u30C3\u30C8\u3067\u30A2\u30AF\u30BB\u30B9\uFF09\u306B\u542B\u307E\u308C\u308B\u3082\u306E:</p>
                <ul>
                    <li><strong>\u95B2\u89A7:</strong> \u30BF\u30A4\u30D7\u5225\u30BF\u30D6\u3067\u6574\u7406\u3055\u308C\u305F\u5168\u9023\u7D61\u5148</li>
                    <li><strong>\u691C\u7D22:</strong> \u5168\u30D7\u30ED\u30D1\u30C6\u30A3\u306E\u30EA\u30A2\u30EB\u30BF\u30A4\u30E0\u30D5\u30A3\u30EB\u30BF\u30EA\u30F3\u30B0</li>
                    <li><strong>\u30BD\u30FC\u30C8:</strong> \u30A2\u30EB\u30D5\u30A1\u30D9\u30C3\u30C8\u9806\u307E\u305F\u306F\u7D44\u7E54\u5225</li>
                    <li><strong>\u4F5C\u6210\u30DC\u30BF\u30F3:</strong> \u30D3\u30E5\u30FC\u304B\u3089\u306E\u8FC5\u901F\u306A\u9023\u7D61\u5148\u4F5C\u6210</li>
                    <li><strong>\u30CA\u30D3\u30B2\u30FC\u30B7\u30E7\u30F3:</strong> \u4EFB\u610F\u306E\u9023\u7D61\u5148\u3092\u30AF\u30EA\u30C3\u30AF\u3057\u3066\u30D5\u30A1\u30A4\u30EB\u3092\u958B\u304F</li>
                </ul>

                <h4>\u{1F4C4} \u30CE\u30FC\u30C8\u5185\u306E\u9023\u7D61\u5148\u30AB\u30FC\u30C9</h4>
                <p>\u9023\u7D61\u5148\u30D5\u30A1\u30A4\u30EB\u306B\u81EA\u52D5\u7684\u306B\u8868\u793A\u3055\u308C\u308B\u30A4\u30F3\u30BF\u30E9\u30AF\u30C6\u30A3\u30D6\u30AB\u30FC\u30C9:</p>
                <ul>
                    <li><strong>\u30D7\u30ED\u30D5\u30A3\u30FC\u30EB\u60C5\u5831:</strong> \u5199\u771F\u3001\u540D\u524D\u3001\u5F79\u8077\u3001\u9023\u7D61\u5148\u8A73\u7D30</li>
                    <li><strong>\u95A2\u4FC2:</strong> \u8272\u5206\u3051\u3055\u308C\u305F\u95A2\u9023\u9023\u7D61\u5148</li>
                    <li><strong>\u7BA1\u7406\u968E\u5C64:</strong> \u7BA1\u7406\u5F79\u8077\u306E\u4EBA\u7269\uFF08\u7DD1\uFF09</li>
                    <li><strong>\u52B4\u50CD\u7D44\u5408\u30E1\u30F3\u30D0\u30FC:</strong> \u7D44\u5408\u4EE3\u8868\u8005\uFF08\u8D64\uFF09</li>
                    <li><strong>\u7D44\u7E54\u30E1\u30F3\u30D0\u30FC:</strong> \u95A2\u9023\u4EBA\u7269\uFF08\u7D2B\uFF09</li>
                    <li><strong>\u30A4\u30F3\u30BF\u30E9\u30AF\u30C6\u30A3\u30D6\u30CA\u30D3\u30B2\u30FC\u30B7\u30E7\u30F3:</strong> \u540D\u524D\u3092\u30AF\u30EA\u30C3\u30AF\u3057\u3066\u95A2\u9023\u9023\u7D61\u5148\u306B\u30B8\u30E3\u30F3\u30D7</li>
                </ul>

                <h4>\u2699\uFE0F \u521D\u671F\u8A2D\u5B9A</h4>
                <p><strong>1. \u9023\u7D61\u5148\u30BF\u30A4\u30D7\u3092\u6709\u52B9\u5316:</strong> \u5FC5\u8981\u306A\u30BF\u30A4\u30D7\u3092\u9078\u629E\uFF08\u4EBA\u7269\u3001\u4F1A\u793E\u3001\u52B4\u50CD\u7D44\u5408\u3001\u7D44\u7E54\uFF09</p>
                <p><strong>2. \u30D5\u30A9\u30EB\u30C0\u3092\u8A2D\u5B9A:</strong> \u5404\u9023\u7D61\u5148\u30BF\u30A4\u30D7\u3092\u4FDD\u5B58\u3059\u308B\u30D5\u30A9\u30EB\u30C0\u3092\u8A2D\u5B9A</p>
                <p><strong>3. \u30C6\u30F3\u30D7\u30EC\u30FC\u30C8\u3092\u30AB\u30B9\u30BF\u30DE\u30A4\u30BA:</strong> \u5FC5\u8981\u306B\u5FDC\u3058\u3066\u30C7\u30D5\u30A9\u30EB\u30C8\u30C6\u30F3\u30D7\u30EC\u30FC\u30C8\u3092\u8ABF\u6574</p>

                <h4>\u{1F4DD} \u9023\u7D61\u5148\u306E\u4F5C\u6210</h4>
                <p><strong>\u65B9\u6CD51:</strong> \u9023\u7D61\u5148\u7BA1\u7406\u30D3\u30E5\u30FC\u306E\u300CCreate\u300D\u30DC\u30BF\u30F3\u3092\u4F7F\u7528</p>
                <p><strong>\u65B9\u6CD52:</strong> \u30B3\u30DE\u30F3\u30C9\u30D1\u30EC\u30C3\u30C8\uFF08"Create Contact"\uFF09</p>
                <p><strong>\u65B9\u6CD53:</strong> \u30D5\u30A1\u30A4\u30EB\u30A8\u30AF\u30B9\u30D7\u30ED\u30FC\u30E9\u30FC\u3067\u53F3\u30AF\u30EA\u30C3\u30AF\u3057\u3066\u300CCreate Contact\u300D\u3092\u9078\u629E</p>
                <p>\u30D7\u30E9\u30B0\u30A4\u30F3\u304C\u30BF\u30A4\u30D7\u9078\u629E\u3068\u57FA\u672C\u60C5\u5831\u5165\u529B\u3092\u30AC\u30A4\u30C9\u3057\u307E\u3059\u3002</p>

                <h4>\u{1F4CB} \u9023\u7D61\u5148\u30BF\u30A4\u30D7\u5225\u6A5F\u80FD\u30D7\u30ED\u30D1\u30C6\u30A3</h4>
                <p><strong>\u4EBA\u7269:</strong></p>
                <ul>
                    <li><strong>type:</strong> "People"\uFF08\u5FC5\u9808\uFF09</li>
                    <li><strong>coverImage:</strong> \u30D7\u30ED\u30D5\u30A3\u30FC\u30EB\u5199\u771F\uFF08[[ImageName.jpg]] \u307E\u305F\u306F path/image.jpg\uFF09</li>
                    <li><strong>role:</strong> \u8077\u4F4D - \u30AB\u30FC\u30C9\u306B\u8868\u793A</li>
                    <li><strong>email, phone:</strong> \u9023\u7D61\u5148\u60C5\u5831 - \u30AB\u30FC\u30C9\u306B\u8868\u793A</li>
                    <li><strong>company:</strong> [[CompanyName]] - \u95A2\u4FC2\u30EA\u30F3\u30AF\u3092\u4F5C\u6210</li>
                    <li><strong>organization:</strong> [[OrganizationName]] - \u95A2\u4FC2\u30EA\u30F3\u30AF\u3092\u4F5C\u6210</li>
                    <li><strong>tradeUnion:</strong> [[UnionName]] - \u95A2\u4FC2\u30EA\u30F3\u30AF\u3092\u4F5C\u6210</li>
                    <li><strong>collections:</strong> ["TradeUnion"] - \u7D44\u5408\u30E1\u30F3\u30D0\u30FC\u691C\u51FA\u306B\u5FC5\u8981</li>
                </ul>

                <p><strong>\u4F1A\u793E/\u7D44\u7E54/\u52B4\u50CD\u7D44\u5408:</strong></p>
                <ul>
                    <li><strong>type:</strong> "Company"/"Organization"/"TradeUnion"\uFF08\u5FC5\u9808\uFF09</li>
                    <li><strong>coverImage:</strong> \u30ED\u30B4 - \u30AB\u30FC\u30C9\u3068\u30E1\u30F3\u30D0\u30FC\u30AB\u30FC\u30C9\u306E\u30AA\u30FC\u30D0\u30FC\u30EC\u30A4\u306B\u8868\u793A</li>
                    <li><strong>website:</strong> URL - \u30AF\u30EA\u30C3\u30AF\u53EF\u80FD\u306A\u30EA\u30F3\u30AF\u3068\u3057\u3066\u8868\u793A</li>
                    <li><strong>contactInfo:</strong> \u4E00\u822C\u9023\u7D61\u5148\u8A73\u7D30 - \u30AB\u30FC\u30C9\u306B\u8868\u793A</li>
                    <li><strong>management:</strong> [["PersonName1", "PersonName2"]] - \u7BA1\u7406\u30BB\u30AF\u30B7\u30E7\u30F3\u3092\u8868\u793A</li>
                    <li><strong>people:</strong> [["PersonName1", "PersonName2"]] - \u30E1\u30F3\u30D0\u30FC\u30BB\u30AF\u30B7\u30E7\u30F3\u3092\u8868\u793A\uFF08\u7D44\u7E54/\u7D44\u5408\uFF09</li>
                </ul>

                <p><strong>\u5171\u901A\u30D7\u30ED\u30D1\u30C6\u30A3:</strong></p>
                <ul>
                    <li><strong>description:</strong> \u30AB\u30FC\u30C9\u306E\u8AAC\u660E\u30BB\u30AF\u30B7\u30E7\u30F3\u306B\u8868\u793A</li>
                    <li><strong>tags:</strong> \u6574\u7406\u7528\u306EObsidian\u30BF\u30B0</li>
                    <li><strong>lastUpdated:</strong> \u81EA\u52D5\u8FFD\u8DE1\u306E\u305F\u3081\u7A7A\u767D\u306B\u3057\u3066\u304A\u304F</li>
                </ul>

                <h4>\u{1F517} \u95A2\u4FC2\u306E\u4ED5\u7D44\u307F</h4>
                <p>\u30D7\u30E9\u30B0\u30A4\u30F3\u306F\u4EE5\u4E0B\u306E\u5834\u5408\u306B\u81EA\u52D5\u7684\u306B\u95A2\u4FC2\u3092\u691C\u51FA\u3057\u307E\u3059:</p>
                <ul>
                    <li>\u4EBA\u7269\u306E<strong>company</strong>\u30D7\u30ED\u30D1\u30C6\u30A3\u3092\u8A2D\u5B9A \u2192 \u4F1A\u793E\u306E\u7BA1\u7406/\u4EBA\u7269\u306B\u8868\u793A</li>
                    <li><strong>management</strong>\u914D\u5217\u306B\u8FFD\u52A0 \u2192 \u7D44\u7E54\u30AB\u30FC\u30C9\u306B\u7BA1\u7406\u30BB\u30AF\u30B7\u30E7\u30F3\u8868\u793A</li>
                    <li><strong>tradeUnion</strong> + collections: ["TradeUnion"]\u3092\u8A2D\u5B9A \u2192 \u7D44\u5408\u30E1\u30F3\u30D0\u30FC\u30B7\u30C3\u30D7\u8868\u793A</li>
                </ul>

                <h4>\u{1F4A1} \u30D2\u30F3\u30C8</h4>
                <ul>
                    <li>\u9023\u7D61\u5148\u30D5\u30A1\u30A4\u30EB\u306B\u306F\u4E00\u8CAB\u3057\u305F\u547D\u540D\u3092\u4F7F\u7528</li>
                    <li>coverImage\u30D7\u30ED\u30D1\u30C6\u30A3\u3067\u30D7\u30ED\u30D5\u30A3\u30FC\u30EB\u5199\u771F\u3092\u8FFD\u52A0</li>
                    <li>\u672A\u4F7F\u7528\u306E\u9023\u7D61\u5148\u30BF\u30A4\u30D7\u3092\u7121\u52B9\u306B\u3057\u3066\u30A4\u30F3\u30BF\u30FC\u30D5\u30A7\u30FC\u30B9\u3092\u7C21\u7D20\u5316</li>
                    <li>\u5168\u3066\u306E\u9023\u7D61\u5148\u53C2\u7167\u306B[[WikiLinks]]\u5F62\u5F0F\u3092\u4F7F\u7528</li>
                </ul>
            `
    };
    return instructions[language] || instructions.en;
  }
};

// src/link-resolver.ts
var LinkResolver = class {
  constructor(app, settings) {
    this.contactCache = /* @__PURE__ */ new Map();
    this.app = app;
    this.settings = settings;
  }
  updateSettings(settings) {
    this.settings = settings;
    this.invalidateCache();
  }
  invalidateCache() {
    this.contactCache.clear();
  }
  invalidateFileCache(filePath) {
    const keysToDelete = [];
    for (const key of this.contactCache.keys()) {
      if (key.startsWith(filePath + ":")) {
        keysToDelete.push(key);
      }
    }
    keysToDelete.forEach((key) => this.contactCache.delete(key));
  }
  async getManagementForCompany(companyName) {
    const allPeople = await this.getAllPeopleContacts();
    return allPeople.filter((person) => {
      const contact = person.contact;
      return contact.company === companyName && !contact.tradeUnion;
    }).map((person) => this.getDisplayName(person.filename));
  }
  async getPeopleForOrganization(orgName, orgType) {
    const allPeople = await this.getAllPeopleContacts();
    const property = orgType === "TradeUnion" ? "tradeUnion" : "organization";
    return allPeople.filter((person) => {
      const contact = person.contact;
      return contact[property] === orgName;
    }).map((person) => this.getDisplayName(person.filename));
  }
  async getAllContactsOfType(contactType) {
    const folders = this.getFoldersForContactType(contactType);
    const contacts = [];
    for (const folder of folders) {
      const folderContacts = await this.getContactsInFolder(folder, contactType);
      contacts.push(...folderContacts);
    }
    return contacts;
  }
  async getAllPeopleContacts() {
    return this.getAllContactsOfType("People");
  }
  async getAllCompanyContacts() {
    return this.getAllContactsOfType("Company");
  }
  async getAllTradeUnionContacts() {
    return this.getAllContactsOfType("TradeUnion");
  }
  async getAllOrganizationContacts() {
    return this.getAllContactsOfType("Organization");
  }
  async getContactsInFolder(folderPath, expectedType) {
    const folder = this.app.vault.getAbstractFileByPath(folderPath);
    if (!folder)
      return [];
    const contacts = [];
    const files = this.app.vault.getMarkdownFiles().filter(
      (file) => file.path.startsWith(folderPath + "/") || file.path === folderPath
    );
    for (const file of files) {
      const cacheKey = file.path + ":" + file.stat.mtime;
      let contactResult = this.contactCache.get(cacheKey);
      if (!contactResult) {
        contactResult = await this.parseContactFile(file);
        if (contactResult) {
          this.contactCache.set(cacheKey, contactResult);
        }
      }
      if (contactResult && (!expectedType || contactResult.contact.type === expectedType)) {
        contacts.push(contactResult);
      }
    }
    return contacts;
  }
  async parseContactFile(file) {
    try {
      const metadata = this.app.metadataCache.getFileCache(file);
      if (!(metadata == null ? void 0 : metadata.frontmatter))
        return null;
      const frontmatter = metadata.frontmatter;
      const rawType = frontmatter.type;
      const contactType = this.normalizeContactType(rawType);
      if (!contactType) {
        return null;
      }
      const contact = this.createContactFromFrontmatter(frontmatter, contactType, file);
      if (!contact)
        return null;
      return {
        contact,
        filename: file.basename,
        path: file.path
      };
    } catch (error) {
      console.error("Error parsing contact file:", file.path, error);
      return null;
    }
  }
  createContactFromFrontmatter(frontmatter, contactType, file) {
    try {
      const baseContact = {
        type: contactType,
        description: frontmatter.description || void 0,
        lastUpdated: this.getLastUpdatedValue(frontmatter.lastUpdated, file),
        tags: this.parseArrayField(frontmatter.tags),
        country: this.parseArrayField(frontmatter.country),
        collections: this.parseArrayField(frontmatter.collections),
        title: this.parseStringField(frontmatter.title),
        aliases: this.parseArrayField(frontmatter.aliases)
      };
      switch (contactType) {
        case "People":
          return {
            ...baseContact,
            type: "People",
            coverImage: this.parseStringField(frontmatter.coverImage),
            phone: this.parseStringField(frontmatter.phone),
            email: this.parseStringField(frontmatter.email),
            role: this.parseStringField(frontmatter.role),
            tradeUnion: this.parseStringField(frontmatter.tradeUnion),
            company: this.parseStringField(frontmatter.company),
            organization: this.parseStringField(frontmatter.organization),
            linkedin: this.parseStringField(frontmatter.linkedin)
          };
        case "Company":
          return {
            ...baseContact,
            type: "Company",
            coverImage: this.parseStringField(frontmatter.coverImage),
            activeProjects: this.parseArrayField(frontmatter.activeProjects),
            contactInfo: this.parseStringField(frontmatter.contactInfo),
            coordinator: this.parseArrayField(frontmatter.coordinator),
            website: this.parseStringField(frontmatter.website),
            folder: this.parseStringField(frontmatter.folder),
            management: this.parseArrayField(frontmatter.management)
          };
        case "TradeUnion":
          return {
            ...baseContact,
            type: "TradeUnion",
            coverImage: this.parseStringField(frontmatter.coverImage),
            activeProjects: this.parseArrayField(frontmatter.activeProjects),
            contactInfo: this.parseStringField(frontmatter.contactInfo),
            website: this.parseStringField(frontmatter.website),
            folder: this.parseStringField(frontmatter.folder),
            people: this.parseArrayField(frontmatter.people)
          };
        case "Organization":
          return {
            ...baseContact,
            type: "Organization",
            coverImage: this.parseStringField(frontmatter.coverImage),
            activeProjects: this.parseArrayField(frontmatter.activeProjects),
            contactInfo: this.parseStringField(frontmatter.contactInfo),
            website: this.parseStringField(frontmatter.website),
            folder: this.parseStringField(frontmatter.folder),
            people: this.parseArrayField(frontmatter.people)
          };
        default:
          return null;
      }
    } catch (error) {
      console.error("Error creating contact from frontmatter:", error);
      return null;
    }
  }
  parseStringField(value) {
    if (value === null || value === void 0 || value === "") {
      return void 0;
    }
    const stringValue = String(value).trim();
    return stringValue.length > 0 ? stringValue : void 0;
  }
  parseArrayField(value) {
    if (!value)
      return void 0;
    if (Array.isArray(value))
      return value.map(String).filter((item) => item.trim().length > 0);
    if (typeof value === "string") {
      const items = value.split(",").map((item) => item.trim()).filter((item) => item.length > 0);
      return items.length > 0 ? items : void 0;
    }
    const stringValue = String(value).trim();
    return stringValue.length > 0 ? [stringValue] : void 0;
  }
  async refreshDynamicLinks(contactPath) {
    const file = this.app.vault.getAbstractFileByPath(contactPath);
    if (!file)
      return;
    const contactResult = await this.parseContactFile(file);
    if (!contactResult)
      return;
    const contact = contactResult.contact;
    if (contact.type === "People") {
      await this.updateRelatedOrganizations(contact, contactResult.filename);
    } else if (contact.type === "Company") {
      await this.updateCompanyManagement(contactResult.filename);
    } else if (contact.type === "TradeUnion" || contact.type === "Organization") {
      await this.updateOrganizationPeople(contactResult.filename, contact.type);
    }
  }
  async updateRelatedOrganizations(person, personName) {
    const displayName = this.getDisplayName(personName);
    if (person.company) {
      await this.updateCompanyManagement(person.company);
    }
    if (person.tradeUnion) {
      await this.updateOrganizationPeople(person.tradeUnion, "TradeUnion");
    }
    if (person.organization) {
      await this.updateOrganizationPeople(person.organization, "Organization");
    }
  }
  async updateCompanyManagement(companyName) {
    const management = await this.getManagementForCompany(companyName);
    await this.updateContactField(companyName, "Company", "Management", management);
  }
  async updateOrganizationPeople(orgName, orgType) {
    const people = await this.getPeopleForOrganization(orgName, orgType);
    await this.updateContactField(orgName, orgType, "people", people);
  }
  async updateContactField(contactName, contactType, fieldName, value) {
    const contacts = await this.getAllContactsOfType(contactType);
    const contact = contacts.find((c) => this.getDisplayName(c.filename) === contactName);
    if (!contact)
      return;
    const file = this.app.vault.getAbstractFileByPath(contact.path);
    if (!file)
      return;
    try {
      const content = await this.app.vault.read(file);
      const updatedContent = this.updateFrontmatterField(content, fieldName, value);
      await this.app.vault.modify(file, updatedContent);
      this.invalidateCache();
    } catch (error) {
      console.error("Error updating contact field:", error);
    }
  }
  updateFrontmatterField(content, fieldName, value) {
    const frontmatterRegex = /^---\n(.*?)\n---/s;
    const match = content.match(frontmatterRegex);
    if (!match)
      return content;
    let frontmatter = match[1];
    const fieldRegex = new RegExp(`^${fieldName}:.*$`, "m");
    const fieldValue = value.length > 0 ? value.join(", ") : "";
    const newFieldLine = `${fieldName}: ${fieldValue}`;
    if (frontmatter.match(fieldRegex)) {
      frontmatter = frontmatter.replace(fieldRegex, newFieldLine);
    } else {
      frontmatter += `
${newFieldLine}`;
    }
    return content.replace(frontmatterRegex, `---
${frontmatter}
---`);
  }
  getLastUpdatedValue(frontmatterValue, file) {
    if (frontmatterValue && frontmatterValue !== "file.mtime") {
      return String(frontmatterValue);
    }
    if (file) {
      return new Date(file.stat.mtime).toISOString().split("T")[0];
    }
    return void 0;
  }
  getDisplayName(filename) {
    return filename.replace(/\.md$/, "");
  }
  normalizeContactType(rawType) {
    if (!rawType || typeof rawType !== "string") {
      return null;
    }
    const normalizedType = rawType.toLowerCase().trim();
    switch (normalizedType) {
      case "people":
      case "person":
        return "People";
      case "company":
      case "companies":
        return "Company";
      case "tradeunion":
      case "trade union":
      case "union":
        return "TradeUnion";
      case "organization":
      case "organisation":
      case "org":
        return "Organization";
      default:
        return null;
    }
  }
  getFoldersForContactType(contactType) {
    switch (contactType) {
      case "People":
        return this.settings.peopleFolders;
      case "Company":
        return this.settings.companyFolders;
      case "TradeUnion":
        return this.settings.tradeUnionFolders;
      case "Organization":
        return this.settings.organizationFolders;
      default:
        return [];
    }
  }
};

// src/file-manager.ts
var import_obsidian2 = require("obsidian");

// src/frontmatter-utils.ts
var FrontmatterUtils = class {
  /**
   * Format a value for YAML frontmatter
   * @param value - The value to format
   * @param key - The property key (for special handling like tags)
   * @returns Formatted string for YAML frontmatter
   */
  static formatFrontmatterValue(value, key) {
    console.log(`\u{1F527} FrontmatterUtils.formatFrontmatterValue called:`);
    console.log(`   Key: ${key}`);
    console.log(`   Value:`, value);
    console.log(`   Is Array:`, Array.isArray(value));
    if (value === null || value === void 0 || value === "") {
      console.log(`   \u2192 Returning empty string`);
      return "";
    }
    if (Array.isArray(value)) {
      const filteredValue = value.filter((item) => item && item.trim());
      if (filteredValue.length === 0) {
        console.log(`   \u2192 Array is empty after filtering, returning empty`);
        return "";
      }
      console.log(`   \u2192 Filtered array:`, filteredValue);
      const escapedValues = filteredValue.map((val) => {
        if (val.includes("[") || val.includes("]") || val.includes(",") || val.includes(":")) {
          return `"${val.replace(/"/g, '\\"')}"`;
        }
        return val;
      });
      const result2 = `[${escapedValues.join(", ")}]`;
      console.log(`   \u2192 Array result: "${result2}"`);
      return result2;
    }
    const result = String(value);
    console.log(`   \u2192 String result: "${result}"`);
    return result;
  }
  /**
   * Update frontmatter fields in a markdown content
   * @param content - Original markdown content with frontmatter
   * @param updates - Object with key-value pairs to update
   * @returns Updated markdown content
   */
  static updateFrontmatterFields(content, updates) {
    console.log(`\u{1F504} FrontmatterUtils.updateFrontmatterFields called with updates:`, updates);
    const frontmatterRegex = /^---\n(.*?)\n---/s;
    const match = content.match(frontmatterRegex);
    if (!match) {
      const frontmatter2 = Object.entries(updates).map(([key, value]) => `${key}: ${this.formatFrontmatterValue(value, key)}`).join("\n");
      return `---
${frontmatter2}
---

${content}`;
    }
    let frontmatter = match[1];
    const lines = frontmatter.split("\n");
    const updatedLines = [];
    const processedKeys = /* @__PURE__ */ new Set();
    for (const line of lines) {
      const colonIndex = line.indexOf(":");
      if (colonIndex === -1) {
        updatedLines.push(line);
        continue;
      }
      const key = line.substring(0, colonIndex).trim();
      if (updates.hasOwnProperty(key)) {
        const formattedValue = this.formatFrontmatterValue(updates[key], key);
        updatedLines.push(`${key}: ${formattedValue}`);
        processedKeys.add(key);
      } else {
        updatedLines.push(line);
      }
    }
    for (const [key, value] of Object.entries(updates)) {
      if (key === "type" || processedKeys.has(key))
        continue;
      const formattedValue = this.formatFrontmatterValue(value, key);
      updatedLines.push(`${key}: ${formattedValue}`);
    }
    const newFrontmatter = updatedLines.join("\n");
    return content.replace(frontmatterRegex, `---
${newFrontmatter}
---`);
  }
  /**
   * Helper function to convert array to string for display purposes
   * @param arr - Array to convert
   * @returns Comma-separated string
   */
  static arrayToString(arr) {
    if (!arr || !Array.isArray(arr))
      return "";
    return arr.join(", ");
  }
  /**
   * Helper function to convert string to array from form input
   * @param str - Comma-separated string
   * @returns Array of trimmed strings
   */
  static stringToArray(str) {
    if (!str || !str.trim())
      return [];
    return str.split(",").map((item) => item.trim()).filter((item) => item.length > 0);
  }
};

// src/file-manager.ts
var FileManager = class {
  constructor(app, settings) {
    this.app = app;
    this.settings = settings;
  }
  updateSettings(settings) {
    this.settings = settings;
  }
  async createContactFile(contactName, contactType, folderPath, initialData = {}) {
    try {
      const targetFolder = folderPath || this.getDefaultFolderForType(contactType);
      const template = this.getTemplateForType(contactType);
      const fileName = this.sanitizeFileName(contactName);
      const filePath = (0, import_obsidian2.normalizePath)(`${targetFolder}/${fileName}.md`);
      await this.ensureFolderExists(targetFolder);
      if (this.app.vault.getAbstractFileByPath(filePath)) {
        throw new Error(`File already exists: ${filePath}`);
      }
      const content = this.processTemplate(template, contactName, initialData);
      const file = await this.app.vault.create(filePath, content);
      return file;
    } catch (error) {
      console.error("Error creating contact file:", error);
      return null;
    }
  }
  // Deprecated: This method is no longer used since contact creation was simplified
  // async moveImageToContactFolder(
  //     imageFile: File,
  //     contactType: ObjectType,
  //     suggestedName?: string
  // ): Promise<string | null> {
  //     try {
  //         const targetFolder = contactType === 'People'
  //             ? 'Images/Profiles'  // Hardcoded fallback
  //             : 'Images/Logos';    // Hardcoded fallback
  //         await this.ensureFolderExists(targetFolder);
  //
  //         const fileName = suggestedName || imageFile.name;
  //         const sanitizedName = this.sanitizeFileName(fileName);
  //         const filePath = normalizePath(`${targetFolder}/${sanitizedName}`);
  //
  //         if (this.app.vault.getAbstractFileByPath(filePath)) {
  //             const timestamp = Date.now();
  //             const nameParts = sanitizedName.split('.');
  //             const extension = nameParts.pop();
  //             const baseName = nameParts.join('.');
  //             const newPath = normalizePath(`${targetFolder}/${baseName}_${timestamp}.${extension}`);
  //
  //             const arrayBuffer = await imageFile.arrayBuffer();
  //             await this.app.vault.createBinary(newPath, arrayBuffer);
  //             return newPath;
  //         } else {
  //             const arrayBuffer = await imageFile.arrayBuffer();
  //             await this.app.vault.createBinary(filePath, arrayBuffer);
  //             return filePath;
  //         }
  //     } catch (error) {
  //         console.error('Error moving image file:', error);
  //         return null;
  //     }
  // }
  // Deprecated: This method is no longer used since contact creation was simplified
  // async copyImageToContactFolder(
  //     sourcePath: string,
  //     contactType: ObjectType,
  //     suggestedName?: string
  // ): Promise<string | null> {
  //     try {
  //         const sourceFile = this.app.vault.getAbstractFileByPath(sourcePath) as TFile;
  //         if (!sourceFile) {
  //             throw new Error(`Source file not found: ${sourcePath}`);
  //         }
  //
  //         const targetFolder = contactType === 'People'
  //             ? 'Images/Profiles'  // Hardcoded fallback
  //             : 'Images/Logos';    // Hardcoded fallback
  //
  //         await this.ensureFolderExists(targetFolder);
  //
  //         const fileName = suggestedName || sourceFile.name;
  //         const sanitizedName = this.sanitizeFileName(fileName);
  //         const filePath = normalizePath(`${targetFolder}/${sanitizedName}`);
  //
  //         if (this.app.vault.getAbstractFileByPath(filePath)) {
  //             const timestamp = Date.now();
  //             const nameParts = sanitizedName.split('.');
  //             const extension = nameParts.pop();
  //             const baseName = nameParts.join('.');
  //             const newPath = normalizePath(`${targetFolder}/${baseName}_${timestamp}.${extension}`);
  //
  //             await this.app.vault.copy(sourceFile, newPath);
  //             return newPath;
  //         } else {
  //             await this.app.vault.copy(sourceFile, filePath);
  //             return filePath;
  //         }
  //     } catch (error) {
  //         console.error('Error copying image file:', error);
  //         return null;
  //     }
  // }
  async ensureFolderExists(folderPath) {
    const normalizedPath = (0, import_obsidian2.normalizePath)(folderPath);
    const folder = this.app.vault.getAbstractFileByPath(normalizedPath);
    if (!folder) {
      await this.app.vault.createFolder(normalizedPath);
    } else if (!(folder instanceof import_obsidian2.TFolder)) {
      throw new Error(`Path exists but is not a folder: ${normalizedPath}`);
    }
  }
  getDefaultFolderForType(contactType) {
    switch (contactType) {
      case "People":
        return this.settings.peopleFolders[0] || "People";
      case "Company":
        return this.settings.companyFolders[0] || "Companies";
      case "TradeUnion":
        return this.settings.tradeUnionFolders[0] || "TradeUnions";
      case "Organization":
        return this.settings.organizationFolders[0] || "Organizations";
      default:
        return "Contacts";
    }
  }
  getTemplateForType(contactType) {
    switch (contactType) {
      case "People":
        return this.settings.peopleTemplate;
      case "Company":
        return this.settings.companyTemplate;
      case "TradeUnion":
        return this.settings.tradeUnionTemplate;
      case "Organization":
        return this.settings.organizationTemplate;
      default:
        return "";
    }
  }
  processTemplate(template, contactName, data) {
    console.log("\u{1F527} FileManager.processTemplate called with data:", data);
    let processed = template.replace(/\{\{title\}\}/g, contactName).replace(/\{\{date\}\}/g, this.getCurrentDate());
    for (const [key, value] of Object.entries(data)) {
      const placeholder = new RegExp(`\\{\\{${key}\\}\\}`, "g");
      processed = processed.replace(placeholder, String(value));
    }
    const frontmatterMatch = processed.match(/^---\n([\s\S]*?)\n---/);
    if (frontmatterMatch) {
      let frontmatter = frontmatterMatch[1];
      for (const [key, value] of Object.entries(data)) {
        if (key === "name" || key === "folder")
          continue;
        const fieldRegex = new RegExp(`^${key}:\\s*$`, "m");
        if (fieldRegex.test(frontmatter)) {
          frontmatter = frontmatter.replace(fieldRegex, `${key}: ${FrontmatterUtils.formatFrontmatterValue(value, key)}`);
        } else if (!frontmatter.includes(`${key}:`)) {
          const objectTypeMatch = frontmatter.match(/^type:.*$/m);
          if (objectTypeMatch) {
            const insertAfter = objectTypeMatch.index + objectTypeMatch[0].length;
            frontmatter = frontmatter.slice(0, insertAfter) + `
${key}: ${FrontmatterUtils.formatFrontmatterValue(value, key)}` + frontmatter.slice(insertAfter);
          }
        }
      }
      processed = processed.replace(frontmatterMatch[0], `---
${frontmatter}
---`);
    }
    return processed;
  }
  getCurrentDate() {
    return new Date().toISOString().split("T")[0];
  }
  sanitizeFileName(fileName) {
    return fileName.replace(/[<>:"/\\|?*]/g, "").replace(/\s+/g, " ").trim();
  }
  getFoldersForContactType(contactType) {
    switch (contactType) {
      case "People":
        return this.settings.peopleFolders;
      case "Company":
        return this.settings.companyFolders;
      case "TradeUnion":
        return this.settings.tradeUnionFolders;
      case "Organization":
        return this.settings.organizationFolders;
      default:
        return [];
    }
  }
  async getImageFiles(folderPath) {
    const folder = this.app.vault.getAbstractFileByPath(folderPath);
    if (!folder)
      return [];
    const imageExtensions = [".jpg", ".jpeg", ".png", ".gif", ".bmp", ".svg", ".webp"];
    return this.app.vault.getFiles().filter((file) => {
      const isInFolder = file.path.startsWith(folderPath + "/");
      const hasImageExtension = imageExtensions.some(
        (ext) => file.path.toLowerCase().endsWith(ext)
      );
      return isInFolder && hasImageExtension;
    });
  }
  async validateImagePath(imagePath) {
    if (!imagePath)
      return false;
    const file = this.app.vault.getAbstractFileByPath(imagePath);
    return file instanceof import_obsidian2.TFile;
  }
  async updateContactFrontmatter(filePath, updates) {
    try {
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (!file)
        return false;
      const content = await this.app.vault.read(file);
      const updatedContent = FrontmatterUtils.updateFrontmatterFields(content, updates);
      if (updatedContent !== content) {
        await this.app.vault.modify(file, updatedContent);
        return true;
      }
      return false;
    } catch (error) {
      console.error("Error updating contact frontmatter:", error);
      return false;
    }
  }
};

// src/contact-creator.ts
var import_obsidian3 = require("obsidian");
var ContactCreator = class extends import_obsidian3.Modal {
  constructor(app, settings, fileManager, preselectedType) {
    super(app);
    this.nameInput = "";
    this.selectedFolder = "";
    this.settings = settings;
    this.fileManager = fileManager;
    this.preselectedType = preselectedType;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("contact-creator-modal");
    contentEl.createEl("h2", { text: "Create New Contact" });
    if (!this.preselectedType || !this.settings.enabledContactTypes.includes(this.preselectedType)) {
      this.renderTypeSelection(contentEl);
    } else {
      this.renderNameInput(contentEl, this.preselectedType);
    }
  }
  onClose() {
    this.nameInput = "";
    this.selectedFolder = "";
  }
  renderTypeSelection(container) {
    const typeContainer = container.createDiv({ cls: "contact-type-selection" });
    typeContainer.createEl("h3", { text: "Select Contact Type" });
    const buttonContainer = typeContainer.createDiv({ cls: "contact-type-buttons" });
    const types = [
      { type: "People", label: "People", icon: "\u{1F464}" },
      { type: "Company", label: "Company", icon: "\u{1F3E2}" },
      { type: "TradeUnion", label: "Trade Union", icon: "\u{1F91D}" },
      { type: "Organization", label: "Organization", icon: "\u{1F3DB}\uFE0F" }
    ];
    const enabledTypes = types.filter(
      ({ type }) => this.settings.enabledContactTypes.includes(type)
    );
    enabledTypes.forEach(({ type, label, icon }) => {
      const button = buttonContainer.createEl("button", {
        cls: "contact-type-button",
        text: `${icon} ${label}`
      });
      button.addEventListener("click", () => {
        container.empty();
        this.renderNameInput(container, type);
      });
    });
  }
  renderNameInput(container, contactType) {
    const formContainer = container.createDiv({ cls: "contact-form" });
    formContainer.createEl("h3", { text: `Create ${contactType} Contact` });
    const basicSection = formContainer.createDiv({ cls: "form-section" });
    basicSection.createEl("h4", { text: "Basic Information" });
    new import_obsidian3.Setting(basicSection).setName("Name").setDesc(`Name of the ${contactType.toLowerCase()}`).addText((text) => text.setPlaceholder(`Enter ${contactType.toLowerCase()} name`).onChange((value) => {
      this.nameInput = value;
    }));
    new import_obsidian3.Setting(basicSection).setName("Folder").setDesc("Choose which folder to create the contact in").addDropdown((dropdown) => {
      const folders = this.getFoldersForContactType(contactType);
      folders.forEach((folder) => {
        dropdown.addOption(folder, folder);
      });
      dropdown.onChange((value) => {
        this.selectedFolder = value;
      });
      this.selectedFolder = folders[0];
      return dropdown;
    });
    this.renderFormActions(formContainer, contactType);
  }
  renderFormActions(container, contactType) {
    const actionsContainer = container.createDiv({ cls: "form-actions" });
    const cancelButton = actionsContainer.createEl("button", {
      text: "Cancel",
      cls: "contact-form-button-secondary"
    });
    cancelButton.addEventListener("click", () => {
      this.close();
    });
    const createButton = actionsContainer.createEl("button", {
      text: `Create ${contactType}`,
      cls: "contact-form-button-primary"
    });
    createButton.addEventListener("click", async () => {
      await this.createContact(contactType);
    });
  }
  async createContact(contactType) {
    if (!this.nameInput.trim()) {
      new import_obsidian3.Notice("Please enter a name for the contact");
      return;
    }
    try {
      const createdFile = await this.fileManager.createContactFile(
        this.nameInput,
        contactType,
        this.selectedFolder
      );
      if (createdFile) {
        new import_obsidian3.Notice(`${contactType} contact "${this.nameInput}" created successfully!`);
        await this.app.workspace.getLeaf().openFile(createdFile);
        this.close();
      } else {
        new import_obsidian3.Notice(`Failed to create ${contactType} contact`);
      }
    } catch (error) {
      console.error("Error creating contact:", error);
      new import_obsidian3.Notice(`Error creating ${contactType} contact: ${error.message}`);
    }
  }
  getFoldersForContactType(contactType) {
    switch (contactType) {
      case "People":
        return this.settings.peopleFolders;
      case "Company":
        return this.settings.companyFolders;
      case "TradeUnion":
        return this.settings.tradeUnionFolders;
      case "Organization":
        return this.settings.organizationFolders;
      default:
        return [""];
    }
  }
};

// src/contact-card-view.ts
var import_obsidian4 = require("obsidian");
var ContactCardView = class extends import_obsidian4.Component {
  constructor(app, settings, linkResolver) {
    super();
    this.app = app;
    this.settings = settings;
    this.linkResolver = linkResolver;
  }
  updateSettings(settings) {
    this.settings = settings;
  }
  extractLinkText(value) {
    const linkMatch = value.match(/\[\[([^\]]+)\]\]/);
    if (linkMatch) {
      const linkContent = linkMatch[1];
      return linkContent.includes("|") ? linkContent.split("|")[0].trim() : linkContent;
    }
    return value;
  }
  async renderCard(contact, container, filePath) {
    const contactInfoHeading = this.findContactInformationHeading(container);
    if (!contactInfoHeading)
      return;
    let insertPoint = contactInfoHeading.parentElement;
    if (!insertPoint)
      return;
    const existingCard = insertPoint.querySelector(".contact-card-modern");
    if (existingCard) {
      existingCard.remove();
    }
    let nextElement = contactInfoHeading.nextElementSibling;
    const cardContainer = createDiv({ cls: "contact-card-container" });
    const card = cardContainer.createDiv({ cls: `contact-card-modern ${contact.type.toLowerCase()}` });
    if (nextElement) {
      insertPoint.insertBefore(cardContainer, nextElement);
    } else {
      insertPoint.appendChild(cardContainer);
    }
    switch (contact.type) {
      case "People":
        await this.renderModernPeopleCard(contact, card, filePath);
        break;
      case "Company":
        await this.renderModernCompanyCard(contact, card, filePath);
        break;
      case "TradeUnion":
        await this.renderModernTradeUnionCard(contact, card, filePath);
        break;
      case "Organization":
        await this.renderModernOrganizationCard(contact, card, filePath);
        break;
    }
    this.addEditButton(card, contact, filePath);
    this.addCardInteractivity(card, contact, filePath);
  }
  findContactInformationHeading(container) {
    var _a;
    const headings = container.querySelectorAll("h1, h2, h3, h4, h5, h6");
    for (const heading of Array.from(headings)) {
      if ((_a = heading.textContent) == null ? void 0 : _a.toLowerCase().includes("contact card")) {
        return heading;
      }
    }
    return null;
  }
  async renderModernPeopleCard(contact, container, filePath) {
    const mainLayout = container.createDiv({ cls: "card-layout" });
    const leftSection = mainLayout.createDiv({ cls: "card-left-section" });
    const imageContainer = leftSection.createDiv({ cls: "card-image-section" });
    const imagePath = this.getImagePath(contact.coverImage);
    if (imagePath) {
      const img = imageContainer.createEl("img", {
        cls: "card-profile-image",
        attr: { src: this.getImageSrc(imagePath) }
      });
      img.onerror = () => {
        imageContainer.innerHTML = '<div class="card-image-placeholder">\u{1F464}</div>';
      };
    } else {
      imageContainer.innerHTML = '<div class="card-image-placeholder">\u{1F464}</div>';
    }
    const orgName = contact.tradeUnion || contact.company || contact.organization;
    if (orgName) {
      const logoOverlay = imageContainer.createDiv({ cls: "card-logo-overlay" });
      this.loadOrganizationLogo(logoOverlay, orgName);
    }
    const rightSection = mainLayout.createDiv({ cls: "card-right-section" });
    const header = rightSection.createDiv({ cls: "card-header-section" });
    header.createEl("h3", { text: this.getContactName(filePath), cls: "card-contact-name" });
    const infoGrid = rightSection.createDiv({ cls: "card-info-grid" });
    if (contact.tradeUnion || contact.company || contact.organization || contact.role || contact.email || contact.phone || contact.linkedin) {
      const basicInfo = infoGrid.createDiv({ cls: "card-info-section" });
      if (contact.tradeUnion) {
        const tradeUnionDiv = basicInfo.createDiv({ cls: "card-info-item" });
        tradeUnionDiv.createSpan({ text: "Trade Union: " });
        const cleanTradeUnion = contact.tradeUnion.replace(/^\[\[/, "").replace(/\]\]$/, "");
        const displayText = cleanTradeUnion.includes("|") ? cleanTradeUnion.split("|")[1] : cleanTradeUnion;
        const linkTarget = cleanTradeUnion.includes("|") ? cleanTradeUnion.split("|")[0] : cleanTradeUnion;
        const tradeUnionLink = tradeUnionDiv.createEl("a", {
          text: displayText,
          cls: "contact-link"
        });
        tradeUnionLink.addEventListener("click", (e) => {
          e.preventDefault();
          this.app.workspace.openLinkText(linkTarget, "", false);
        });
      }
      if (contact.company) {
        const companyDiv = basicInfo.createDiv({ cls: "card-info-item" });
        companyDiv.createSpan({ text: "Company: " });
        const cleanCompany = contact.company.replace(/^\[\[/, "").replace(/\]\]$/, "");
        const displayText = cleanCompany.includes("|") ? cleanCompany.split("|")[1] : cleanCompany;
        const linkTarget = cleanCompany.includes("|") ? cleanCompany.split("|")[0] : cleanCompany;
        const companyLink = companyDiv.createEl("a", {
          text: displayText,
          cls: "contact-link"
        });
        companyLink.addEventListener("click", (e) => {
          e.preventDefault();
          this.app.workspace.openLinkText(linkTarget, "", false);
        });
      }
      if (contact.organization) {
        const orgDiv = basicInfo.createDiv({ cls: "card-info-item" });
        orgDiv.createSpan({ text: "Organization: " });
        const cleanOrganization = contact.organization.replace(/^\[\[/, "").replace(/\]\]$/, "");
        const displayText = cleanOrganization.includes("|") ? cleanOrganization.split("|")[1] : cleanOrganization;
        const linkTarget = cleanOrganization.includes("|") ? cleanOrganization.split("|")[0] : cleanOrganization;
        const orgLink = orgDiv.createEl("a", {
          text: displayText,
          cls: "contact-link"
        });
        orgLink.addEventListener("click", (e) => {
          e.preventDefault();
          this.app.workspace.openLinkText(linkTarget, "", false);
        });
      }
      if (contact.role)
        basicInfo.createDiv({ cls: "card-info-item", text: `Role: ${contact.role}` });
      if (contact.email)
        basicInfo.createDiv({ cls: "card-info-item", text: `Email: ${contact.email}` });
      if (contact.phone)
        basicInfo.createDiv({ cls: "card-info-item", text: `Phone: ${contact.phone}` });
      if (contact.linkedin) {
        const linkedinDiv = basicInfo.createDiv({ cls: "card-info-item" });
        linkedinDiv.createEl("a", {
          text: "LinkedIn",
          attr: { href: contact.linkedin, target: "_blank" },
          cls: "linkedin-link"
        });
      }
    }
    if (contact.tags && contact.tags.length > 0) {
      const tagsSection = infoGrid.createDiv({ cls: "card-tags-section" });
      tagsSection.createDiv({ cls: "card-section-label", text: "tags" });
      const tagsContainer = tagsSection.createDiv({ cls: "card-tags-container" });
      contact.tags.forEach((tag) => {
        tagsContainer.createSpan({ text: `#${tag}`, cls: "card-tag-modern" });
      });
    }
    if (contact.description) {
      const summarySection = rightSection.createDiv({ cls: "card-summary-section" });
      summarySection.createDiv({ cls: "card-summary-text", text: contact.description });
    }
  }
  async renderModernCompanyCard(contact, container, filePath) {
    const mainLayout = container.createDiv({ cls: "card-layout" });
    const leftSection = mainLayout.createDiv({ cls: "card-left-section" });
    const imageContainer = leftSection.createDiv({ cls: "card-image-section" });
    const imagePath = this.getImagePath(contact.coverImage);
    if (imagePath) {
      const img = imageContainer.createEl("img", {
        cls: "card-company-logo",
        attr: { src: this.getImageSrc(imagePath) }
      });
      img.onerror = () => {
        imageContainer.innerHTML = '<div class="card-image-placeholder">\u{1F3E2}</div>';
      };
    } else {
      imageContainer.innerHTML = '<div class="card-image-placeholder">\u{1F3E2}</div>';
    }
    const rightSection = mainLayout.createDiv({ cls: "card-right-section" });
    const header = rightSection.createDiv({ cls: "card-header-section" });
    header.createEl("h3", { text: this.getContactName(filePath), cls: "card-contact-name" });
    const infoGrid = rightSection.createDiv({ cls: "card-info-grid" });
    const basicInfo = infoGrid.createDiv({ cls: "card-info-section" });
    if (contact.contactInfo)
      basicInfo.createDiv({ cls: "card-info-item", text: `Contact: ${contact.contactInfo}` });
    if (contact.website)
      basicInfo.createDiv({ cls: "card-info-item", text: `Website: ${contact.website}` });
    if (contact.activeProjects && contact.activeProjects.length > 0) {
      const projectNames = contact.activeProjects.map((p) => this.extractLinkText(p));
      basicInfo.createDiv({ cls: "card-info-item", text: `Projects: ${projectNames.join(", ")}` });
    }
    if (contact.management && contact.management.length > 0) {
      const managementSection = infoGrid.createDiv({ cls: "card-management-section" });
      managementSection.createDiv({ cls: "card-section-label", text: "Management" });
      const managementList = managementSection.createDiv({ cls: "card-management-list" });
      const sortedManagement = [...contact.management].sort((a, b) => {
        const nameA = this.extractLinkText(a);
        const nameB = this.extractLinkText(b);
        return nameA.localeCompare(nameB);
      });
      sortedManagement.forEach((manager) => {
        const managerItem = managementList.createDiv({ cls: "card-management-item" });
        const managerName = this.extractLinkText(manager);
        if (manager.includes("[[") && manager.includes("]]")) {
          const link = managerItem.createEl("a", {
            text: managerName,
            cls: "card-management-link"
          });
          link.addEventListener("click", async (e) => {
            e.preventDefault();
            e.stopPropagation();
            const linkPath = manager.replace(/^\[\[/, "").replace(/\]\]$/, "").split("|")[0];
            await this.app.workspace.openLinkText(linkPath, "", false);
          });
        } else {
          managerItem.textContent = managerName;
        }
      });
    }
    const tradeUnionPeople = await this.getTradeUnionPeopleForCompany(filePath);
    if (tradeUnionPeople.length > 0) {
      const tradeUnionSection = infoGrid.createDiv({ cls: "card-union-section" });
      tradeUnionSection.createDiv({ cls: "card-section-label", text: "Trade Union Representatives" });
      const tradeUnionList = tradeUnionSection.createDiv({ cls: "card-management-list" });
      const sortedTradeUnionPeople = tradeUnionPeople.sort((a, b) => a.name.localeCompare(b.name));
      sortedTradeUnionPeople.forEach((person) => {
        const personItem = tradeUnionList.createDiv({ cls: "card-management-item" });
        const link = personItem.createEl("a", {
          text: person.name,
          cls: "card-management-link card-trade-union-link"
        });
        link.addEventListener("click", async (e) => {
          e.preventDefault();
          e.stopPropagation();
          await this.app.workspace.openLinkText(person.path, "", false);
        });
        if (person.tradeUnion) {
          const unionInfo = personItem.createEl("span", {
            text: ` (${person.tradeUnion})`,
            cls: "card-trade-union-org"
          });
        }
      });
    }
    if (contact.tags && contact.tags.length > 0) {
      const tagsSection = infoGrid.createDiv({ cls: "card-tags-section" });
      const tagsContainer = tagsSection.createDiv({ cls: "card-tags-container" });
      contact.tags.forEach((tag) => {
        tagsContainer.createSpan({ text: `#${tag}`, cls: "card-tag-modern" });
      });
    }
    if (contact.description) {
      const summarySection = rightSection.createDiv({ cls: "card-summary-section" });
      summarySection.createDiv({ cls: "card-summary-text", text: contact.description });
    }
  }
  async renderModernTradeUnionCard(contact, container, filePath) {
    const mainLayout = container.createDiv({ cls: "card-layout" });
    const leftSection = mainLayout.createDiv({ cls: "card-left-section" });
    const imageContainer = leftSection.createDiv({ cls: "card-image-section" });
    const imagePath = this.getImagePath(contact.coverImage);
    if (imagePath) {
      const img = imageContainer.createEl("img", {
        cls: "card-company-logo",
        attr: { src: this.getImageSrc(imagePath) }
      });
      img.onerror = () => {
        imageContainer.innerHTML = '<div class="card-image-placeholder">\u{1F91D}</div>';
      };
    } else {
      imageContainer.innerHTML = '<div class="card-image-placeholder">\u{1F91D}</div>';
    }
    const rightSection = mainLayout.createDiv({ cls: "card-right-section" });
    const header = rightSection.createDiv({ cls: "card-header-section" });
    header.createEl("h3", { text: this.getContactName(filePath), cls: "card-contact-name" });
    const infoGrid = rightSection.createDiv({ cls: "card-info-grid" });
    const basicInfo = infoGrid.createDiv({ cls: "card-info-section" });
    if (contact.contactInfo)
      basicInfo.createDiv({ cls: "card-info-item", text: `Contact: ${contact.contactInfo}` });
    if (contact.website)
      basicInfo.createDiv({ cls: "card-info-item", text: `Website: ${contact.website}` });
    if (contact.activeProjects && contact.activeProjects.length > 0) {
      const projectNames = contact.activeProjects.map((p) => this.extractLinkText(p));
      basicInfo.createDiv({ cls: "card-info-item", text: `Projects: ${projectNames.join(", ")}` });
    }
    const tradeUnionMembers = await this.getMembersForTradeUnion(filePath);
    if (tradeUnionMembers.length > 0) {
      const membersSection = infoGrid.createDiv({ cls: "card-union-section" });
      membersSection.createDiv({ cls: "card-section-label", text: "Members" });
      const membersList = membersSection.createDiv({ cls: "card-management-list" });
      const sortedMembers = tradeUnionMembers.sort((a, b) => a.name.localeCompare(b.name));
      sortedMembers.forEach((person) => {
        const personItem = membersList.createDiv({ cls: "card-management-item" });
        const link = personItem.createEl("a", {
          text: person.name,
          cls: "card-management-link card-trade-union-link"
        });
        link.addEventListener("click", async (e) => {
          e.preventDefault();
          e.stopPropagation();
          await this.app.workspace.openLinkText(person.path, "", false);
        });
      });
    }
    if (contact.tags && contact.tags.length > 0) {
      const tagsSection = infoGrid.createDiv({ cls: "card-tags-section" });
      const tagsContainer = tagsSection.createDiv({ cls: "card-tags-container" });
      contact.tags.forEach((tag) => {
        tagsContainer.createSpan({ text: `#${tag}`, cls: "card-tag-modern" });
      });
    }
    if (contact.description) {
      const summarySection = rightSection.createDiv({ cls: "card-summary-section" });
      summarySection.createDiv({ cls: "card-summary-text", text: contact.description });
    }
  }
  async renderModernOrganizationCard(contact, container, filePath) {
    const mainLayout = container.createDiv({ cls: "card-layout" });
    const leftSection = mainLayout.createDiv({ cls: "card-left-section" });
    const imageContainer = leftSection.createDiv({ cls: "card-image-section" });
    const imagePath = this.getImagePath(contact.coverImage);
    if (imagePath) {
      const img = imageContainer.createEl("img", {
        cls: "card-company-logo",
        attr: { src: this.getImageSrc(imagePath) }
      });
      img.onerror = () => {
        imageContainer.innerHTML = '<div class="card-image-placeholder">\u{1F3DB}\uFE0F</div>';
      };
    } else {
      imageContainer.innerHTML = '<div class="card-image-placeholder">\u{1F3DB}\uFE0F</div>';
    }
    const rightSection = mainLayout.createDiv({ cls: "card-right-section" });
    const header = rightSection.createDiv({ cls: "card-header-section" });
    header.createEl("h3", { text: this.getContactName(filePath), cls: "card-contact-name" });
    const infoGrid = rightSection.createDiv({ cls: "card-info-grid" });
    const basicInfo = infoGrid.createDiv({ cls: "card-info-section" });
    if (contact.contactInfo)
      basicInfo.createDiv({ cls: "card-info-item", text: `Contact: ${contact.contactInfo}` });
    if (contact.website)
      basicInfo.createDiv({ cls: "card-info-item", text: `Website: ${contact.website}` });
    if (contact.activeProjects && contact.activeProjects.length > 0) {
      const projectNames = contact.activeProjects.map((p) => this.extractLinkText(p));
      basicInfo.createDiv({ cls: "card-info-item", text: `Projects: ${projectNames.join(", ")}` });
    }
    const organizationMembers = await this.getMembersForOrganization(filePath);
    if (organizationMembers.length > 0) {
      const membersSection = infoGrid.createDiv({ cls: "card-members-section" });
      membersSection.createDiv({ cls: "card-section-label", text: "Members" });
      const membersList = membersSection.createDiv({ cls: "card-management-list" });
      const sortedMembers = organizationMembers.sort((a, b) => a.name.localeCompare(b.name));
      sortedMembers.forEach((person) => {
        const personItem = membersList.createDiv({ cls: "card-management-item" });
        const link = personItem.createEl("a", {
          text: person.name,
          cls: "card-management-link card-members-link"
        });
        link.addEventListener("click", async (e) => {
          e.preventDefault();
          e.stopPropagation();
          await this.app.workspace.openLinkText(person.path, "", false);
        });
      });
    }
    if (contact.tags && contact.tags.length > 0) {
      const tagsSection = infoGrid.createDiv({ cls: "card-tags-section" });
      const tagsContainer = tagsSection.createDiv({ cls: "card-tags-container" });
      contact.tags.forEach((tag) => {
        tagsContainer.createSpan({ text: `#${tag}`, cls: "card-tag-modern" });
      });
    }
    if (contact.description) {
      const summarySection = rightSection.createDiv({ cls: "card-summary-section" });
      summarySection.createDiv({ cls: "card-summary-text", text: contact.description });
    }
  }
  async renderPeopleCard(contact, container, filePath) {
    const header = container.createDiv({ cls: "contact-header" });
    const body = container.createDiv({ cls: "contact-body" });
    const imagePath = this.getImagePath(contact.coverImage);
    if (imagePath) {
      const imageContainer = header.createDiv({ cls: "image-container" });
      const img = imageContainer.createEl("img", {
        cls: "profile-image",
        attr: { src: this.getImageSrc(imagePath) }
      });
      img.onerror = () => {
        imageContainer.style.display = "none";
      };
    }
    const infoContainer = header.createDiv({ cls: "info-container" });
    infoContainer.createEl("h3", { text: this.getContactName(filePath), cls: "contact-name" });
    if (contact.role) {
      infoContainer.createEl("div", { text: contact.role, cls: "contact-role" });
    }
    if (contact.description) {
      await this.renderMarkdownField(body, "Description", contact.description);
    }
    const fieldsContainer = body.createDiv({ cls: "contact-fields" });
    await this.renderFieldIfExists(fieldsContainer, "Email", contact.email, "email");
    await this.renderFieldIfExists(fieldsContainer, "Phone", contact.phone, "phone");
    await this.renderLinkFieldIfExists(fieldsContainer, "Company", contact.company);
    await this.renderLinkFieldIfExists(fieldsContainer, "Trade Union", contact.tradeUnion);
    await this.renderLinkFieldIfExists(fieldsContainer, "Organization", contact.organization);
    await this.renderFieldIfExists(fieldsContainer, "LinkedIn", contact.linkedin, "url");
    await this.renderTagsIfExists(fieldsContainer, "tags", contact.tags);
    await this.renderArrayFieldIfExists(fieldsContainer, "Country", contact.country);
  }
  async renderCompanyCard(contact, container, filePath) {
    const header = container.createDiv({ cls: "contact-header" });
    const body = container.createDiv({ cls: "contact-body" });
    const imagePath = this.getImagePath(contact.coverImage);
    if (imagePath) {
      const imageContainer = header.createDiv({ cls: "image-container" });
      const img = imageContainer.createEl("img", {
        cls: "org-logo",
        attr: { src: this.getImageSrc(imagePath) }
      });
      img.onerror = () => {
        imageContainer.style.display = "none";
      };
    }
    const infoContainer = header.createDiv({ cls: "info-container" });
    infoContainer.createEl("h3", { text: this.getContactName(filePath), cls: "contact-name" });
    if (contact.description) {
      await this.renderMarkdownField(body, "Description", contact.description);
    }
    const fieldsContainer = body.createDiv({ cls: "contact-fields" });
    await this.renderFieldIfExists(fieldsContainer, "Contact Info", contact.contactInfo, "email");
    await this.renderFieldIfExists(fieldsContainer, "website", contact.website, "url");
    await this.renderArrayFieldIfExists(fieldsContainer, "Coordinator", contact.coordinator);
    await this.renderArrayFieldIfExists(fieldsContainer, "Active Projects", contact.activeProjects);
    await this.renderExternalLinkFieldIfExists(fieldsContainer, "Folder", contact.folder);
    const managementContainer = fieldsContainer.createDiv({ cls: "dropdown-field" });
    await this.renderDynamicDropdown(managementContainer, "Management", filePath, "Company");
    await this.renderTagsIfExists(fieldsContainer, "tags", contact.tags);
    await this.renderArrayFieldIfExists(fieldsContainer, "Country", contact.country);
  }
  async renderTradeUnionCard(contact, container, filePath) {
    const header = container.createDiv({ cls: "contact-header" });
    const body = container.createDiv({ cls: "contact-body" });
    const imagePath = this.getImagePath(contact.coverImage);
    if (imagePath) {
      const imageContainer = header.createDiv({ cls: "image-container" });
      const img = imageContainer.createEl("img", {
        cls: "org-logo",
        attr: { src: this.getImageSrc(imagePath) }
      });
      img.onerror = () => {
        imageContainer.style.display = "none";
      };
    }
    const infoContainer = header.createDiv({ cls: "info-container" });
    infoContainer.createEl("h3", { text: this.getContactName(filePath), cls: "contact-name" });
    if (contact.description) {
      await this.renderMarkdownField(body, "Description", contact.description);
    }
    const fieldsContainer = body.createDiv({ cls: "contact-fields" });
    await this.renderFieldIfExists(fieldsContainer, "Contact Info", contact.contactInfo, "email");
    await this.renderFieldIfExists(fieldsContainer, "website", contact.website, "url");
    await this.renderArrayFieldIfExists(fieldsContainer, "Active Projects", contact.activeProjects);
    await this.renderExternalLinkFieldIfExists(fieldsContainer, "Folder", contact.folder);
    const tradeUnionMembers = await this.getMembersForTradeUnion(filePath);
    if (tradeUnionMembers.length > 0) {
      const membersSection = fieldsContainer.createDiv({ cls: "card-union-section" });
      membersSection.createDiv({ cls: "card-section-label", text: "Members" });
      const membersList = membersSection.createDiv({ cls: "card-management-list" });
      const sortedMembers = tradeUnionMembers.sort((a, b) => a.name.localeCompare(b.name));
      sortedMembers.forEach((person) => {
        const personItem = membersList.createDiv({ cls: "card-management-item" });
        const link = personItem.createEl("a", {
          text: person.name,
          cls: "card-management-link card-trade-union-link"
        });
        link.addEventListener("click", async (e) => {
          e.preventDefault();
          e.stopPropagation();
          await this.app.workspace.openLinkText(person.path, "", false);
        });
      });
    }
    await this.renderTagsIfExists(fieldsContainer, "tags", contact.tags);
    await this.renderArrayFieldIfExists(fieldsContainer, "Country", contact.country);
  }
  async renderOrganizationCard(contact, container, filePath) {
    const header = container.createDiv({ cls: "contact-header" });
    const body = container.createDiv({ cls: "contact-body" });
    const imagePath = this.getImagePath(contact.coverImage);
    if (imagePath) {
      const imageContainer = header.createDiv({ cls: "image-container" });
      const img = imageContainer.createEl("img", {
        cls: "org-logo",
        attr: { src: this.getImageSrc(imagePath) }
      });
      img.onerror = () => {
        imageContainer.style.display = "none";
      };
    }
    const infoContainer = header.createDiv({ cls: "info-container" });
    infoContainer.createEl("h3", { text: this.getContactName(filePath), cls: "contact-name" });
    if (contact.description) {
      await this.renderMarkdownField(body, "Description", contact.description);
    }
    const fieldsContainer = body.createDiv({ cls: "contact-fields" });
    await this.renderFieldIfExists(fieldsContainer, "Contact Info", contact.contactInfo, "email");
    await this.renderFieldIfExists(fieldsContainer, "website", contact.website, "url");
    await this.renderArrayFieldIfExists(fieldsContainer, "Active Projects", contact.activeProjects);
    await this.renderExternalLinkFieldIfExists(fieldsContainer, "Folder", contact.folder);
    const peopleContainer = fieldsContainer.createDiv({ cls: "dropdown-field" });
    await this.renderDynamicDropdown(peopleContainer, "people", filePath, "Organization");
    await this.renderTagsIfExists(fieldsContainer, "tags", contact.tags);
    await this.renderArrayFieldIfExists(fieldsContainer, "Country", contact.country);
  }
  async renderFieldIfExists(container, label, value, type = "text") {
    if (!(value == null ? void 0 : value.trim()))
      return;
    const field = container.createDiv({ cls: "contact-field" });
    if (type === "url" && label.toLowerCase() === "linkedin") {
      field.createEl("a", {
        text: "LinkedIn",
        attr: { href: value, target: "_blank" },
        cls: "field-value linkedin-link"
      });
      return;
    }
    field.createEl("span", { text: label + ": ", cls: "field-label" });
    const valueElement = field.createEl("span", { cls: "field-value" });
    switch (type) {
      case "email":
        valueElement.createEl("a", {
          text: value,
          attr: { href: `mailto:${value}` }
        });
        break;
      case "phone":
        valueElement.createEl("a", {
          text: value,
          attr: { href: `tel:${value}` }
        });
        break;
      case "url":
        const linkText = label.toLowerCase() === "linkedin" ? "LinkedIn" : value;
        valueElement.createEl("a", {
          text: linkText,
          attr: { href: value, target: "_blank" }
        });
        break;
      default:
        valueElement.setText(value);
    }
  }
  async renderArrayFieldIfExists(container, label, values) {
    if (!(values == null ? void 0 : values.length))
      return;
    const field = container.createDiv({ cls: "contact-field" });
    field.createEl("span", { text: label + ": ", cls: "field-label" });
    const valueContainer = field.createDiv({ cls: "field-value array-value" });
    for (let i = 0; i < values.length; i++) {
      const value = values[i].trim();
      if (!value)
        continue;
      if (value.startsWith("[[") && value.endsWith("]]")) {
        const linkText = value.slice(2, -2);
        const link = valueContainer.createEl("a", {
          text: linkText,
          cls: "internal-link"
        });
        link.addEventListener("click", (e) => {
          e.preventDefault();
          this.app.workspace.openLinkText(linkText, "", false);
        });
      } else {
        valueContainer.createSpan({ text: value });
      }
      if (i < values.length - 1) {
        valueContainer.createSpan({ text: ", ", cls: "separator" });
      }
    }
  }
  async renderLinkFieldIfExists(container, label, value) {
    if (!value)
      return;
    const field = container.createDiv({ cls: "contact-field" });
    field.createEl("span", { text: label + ": ", cls: "field-label" });
    const valueElement = field.createEl("span", { cls: "field-value" });
    const actualValue = Array.isArray(value) ? value[0] : value;
    if (!(actualValue == null ? void 0 : actualValue.trim()))
      return;
    const linkText = actualValue.startsWith("[[") && actualValue.endsWith("]]") ? actualValue.slice(2, -2) : actualValue;
    const displayText = linkText.includes("|") ? linkText.split("|")[1] : linkText;
    const linkTarget = linkText.includes("|") ? linkText.split("|")[0] : linkText;
    const link = valueElement.createEl("a", {
      text: displayText,
      cls: "contact-link"
    });
    link.addEventListener("click", (e) => {
      e.preventDefault();
      this.app.workspace.openLinkText(linkTarget, "", false);
    });
  }
  async renderExternalLinkFieldIfExists(container, label, value) {
    if (!(value == null ? void 0 : value.trim()))
      return;
    const field = container.createDiv({ cls: "contact-field" });
    field.createEl("span", { text: label + ": ", cls: "field-label" });
    const valueElement = field.createEl("span", { cls: "field-value" });
    const link = valueElement.createEl("a", {
      text: value,
      cls: "contact-link external-link",
      attr: {
        href: value,
        target: "_blank",
        rel: "noopener noreferrer"
      }
    });
  }
  async renderMarkdownField(container, label, value) {
    if (!(value == null ? void 0 : value.trim()))
      return;
    const field = container.createDiv({ cls: "contact-field markdown-field" });
    field.createEl("div", { text: label + ":", cls: "field-label" });
    const valueContainer = field.createDiv({ cls: "field-value markdown-value" });
    await import_obsidian4.MarkdownRenderer.renderMarkdown(value, valueContainer, "", this);
  }
  async renderTagsIfExists(container, label, tags) {
    if (!(tags == null ? void 0 : tags.length))
      return;
    const field = container.createDiv({ cls: "contact-field tags-field" });
    field.createEl("span", { text: label + ": ", cls: "field-label" });
    const tagsContainer = field.createDiv({ cls: "field-value tags-container" });
    tags.forEach((tag) => {
      const cleanTag = tag.replace(/^#/, "").trim();
      if (!cleanTag)
        return;
      const tagElement = tagsContainer.createEl("a", {
        text: `#${cleanTag}`,
        cls: "tag-item internal-link"
      });
      tagElement.addEventListener("click", (e) => {
        e.preventDefault();
        this.app.internalPlugins.plugins["global-search"].instance.openGlobalSearch(`tag:#${cleanTag}`);
      });
    });
  }
  async renderDynamicDropdown(container, label, filePath, orgType) {
    const field = container.createDiv({ cls: "contact-field dropdown-field" });
    field.createEl("span", { text: label + ": ", cls: "field-label" });
    const dropdownContainer = field.createDiv({ cls: "dropdown-container" });
    const dropdown = dropdownContainer.createDiv({ cls: "dropdown-list" });
    try {
      let items = [];
      const contactName = this.getContactName(filePath);
      switch (orgType) {
        case "Company":
          items = await this.linkResolver.getManagementForCompany(contactName);
          break;
        case "TradeUnion":
          items = await this.linkResolver.getPeopleForOrganization(contactName, "TradeUnion");
          break;
        case "Organization":
          items = await this.linkResolver.getPeopleForOrganization(contactName, "Organization");
          break;
      }
      if (items.length === 0) {
        dropdown.createDiv({ text: `No ${label.toLowerCase()} found`, cls: "dropdown-empty" });
      } else {
        items.forEach((item) => {
          const itemElement = dropdown.createDiv({ text: item, cls: "dropdown-item" });
          itemElement.addEventListener("click", () => {
            this.app.workspace.openLinkText(item, "", false);
          });
        });
      }
    } catch (error) {
      console.error("Error rendering dynamic dropdown:", error);
      dropdown.createDiv({ text: "Error loading data", cls: "dropdown-error" });
    }
  }
  addEditButton(container, contact, filePath) {
    const editButton = container.createEl("button", {
      text: "\u270F\uFE0F",
      cls: "contact-edit-button",
      attr: { title: "Edit contact" }
    });
    editButton.addEventListener("click", async (e) => {
      e.stopPropagation();
      await this.openContactEditor(contact, filePath);
    });
  }
  addCardInteractivity(container, contact, filePath) {
    container.addEventListener("click", (e) => {
      if (e.target && e.target.closest(".contact-edit-button")) {
        return;
      }
      if (e.target && e.target.closest("a")) {
        return;
      }
      this.app.workspace.openLinkText(filePath, "", false);
    });
    container.style.cursor = "pointer";
  }
  getContactName(filePath) {
    const fileName = filePath.split("/").pop() || "";
    return fileName.replace(/\.md$/, "");
  }
  async loadOrganizationLogo(container, orgName) {
    try {
      const cleanName = orgName.replace(/^\[\[/, "").replace(/\]\]$/, "");
      const orgFile = this.app.vault.getAbstractFileByPath(cleanName + ".md") || this.app.metadataCache.getFirstLinkpathDest(cleanName, "");
      if (orgFile) {
        const orgContact = await this.linkResolver.parseContactFile(orgFile);
        if ((orgContact == null ? void 0 : orgContact.contact) && "coverImage" in orgContact.contact && orgContact.contact.coverImage) {
          const logoPath = this.getImagePath(orgContact.contact.coverImage);
          if (logoPath) {
            const img = container.createEl("img", {
              cls: "card-logo-overlay-img",
              attr: { src: this.app.vault.adapter.getResourcePath(logoPath) }
            });
            img.onerror = () => {
              container.innerHTML = "\u{1F3E2}";
            };
            return;
          }
        }
      }
    } catch (error) {
      console.warn("Could not load organization logo:", error);
    }
    container.innerHTML = "\u{1F3E2}";
  }
  async openContactEditor(contact, filePath) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (file && file.path) {
      await this.app.workspace.openLinkText(filePath, "", false);
    }
  }
  async confirmDeleteContact(contact, filePath) {
    const contactName = this.getContactName(filePath);
    const confirmed = await new Promise((resolve) => {
      const modal = new this.app.constructor.Modal(this.app);
      modal.titleEl.setText("Delete Contact");
      modal.contentEl.empty();
      modal.contentEl.createEl("p", {
        text: `Are you sure you want to delete "${contactName}"?`
      });
      modal.contentEl.createEl("p", {
        text: "This action cannot be undone.",
        cls: "mod-warning"
      });
      const buttonContainer = modal.contentEl.createDiv({ cls: "modal-button-container" });
      const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
      cancelBtn.addEventListener("click", () => {
        modal.close();
        resolve(false);
      });
      const deleteBtn = buttonContainer.createEl("button", {
        text: "Delete",
        cls: "mod-warning"
      });
      deleteBtn.addEventListener("click", () => {
        modal.close();
        resolve(true);
      });
      modal.open();
    });
    if (confirmed) {
      try {
        const file = this.app.vault.getAbstractFileByPath(filePath);
        if (file) {
          await this.app.vault.delete(file);
          new this.app.Notice(`Contact "${contactName}" deleted successfully`);
        }
      } catch (error) {
        console.error("Error deleting contact:", error);
        new this.app.Notice("Error deleting contact");
      }
    }
  }
  async getTradeUnionPeopleForCompany(companyFilePath) {
    try {
      const companyName = this.getContactName(companyFilePath);
      const allPeople = await this.linkResolver.getAllContactsOfType("People");
      const tradeUnionPeople = [];
      for (const personResult of allPeople) {
        const person = personResult.contact;
        if (person.company && person.tradeUnion) {
          const personCompanyName = this.extractLinkText(person.company);
          if (personCompanyName === companyName) {
            const tradeUnionName = this.extractLinkText(person.tradeUnion);
            tradeUnionPeople.push({
              name: personResult.filename,
              path: personResult.path,
              tradeUnion: tradeUnionName
            });
          }
        }
      }
      return tradeUnionPeople;
    } catch (error) {
      console.error("Error getting trade union people for company:", error);
      return [];
    }
  }
  async getMembersForTradeUnion(tradeUnionFilePath) {
    try {
      const tradeUnionName = this.getContactName(tradeUnionFilePath);
      const allPeople = await this.linkResolver.getAllContactsOfType("People");
      const members = [];
      for (const personResult of allPeople) {
        const person = personResult.contact;
        const tradeUnionMatch = person.tradeUnion && this.extractLinkText(person.tradeUnion) === tradeUnionName;
        const hasTradeUnionCollection = person.collections && person.collections.some(
          (collection) => this.extractLinkText(collection).toLowerCase().includes("tradeunion")
        );
        if (tradeUnionMatch && hasTradeUnionCollection) {
          members.push({
            name: personResult.filename,
            path: personResult.path
          });
        }
      }
      return members;
    } catch (error) {
      console.error("Error getting members for trade union:", error);
      return [];
    }
  }
  async getMembersForOrganization(organizationFilePath) {
    try {
      const organizationName = this.getContactName(organizationFilePath);
      const allPeople = await this.linkResolver.getAllContactsOfType("People");
      const members = [];
      for (const personResult of allPeople) {
        const person = personResult.contact;
        const organizationMatch = person.organization && this.extractLinkText(person.organization) === organizationName;
        if (organizationMatch) {
          members.push({
            name: personResult.filename,
            path: personResult.path
          });
        }
      }
      return members;
    } catch (error) {
      console.error("Error getting members for organization:", error);
      return [];
    }
  }
  getImagePath(imageInput) {
    if (!(imageInput == null ? void 0 : imageInput.trim()))
      return null;
    if (imageInput.includes("[[") && imageInput.includes("]]")) {
      const linkText = this.extractLinkText(imageInput);
      const resolvedFile = this.app.metadataCache.getFirstLinkpathDest(linkText, "");
      if (resolvedFile) {
        console.log(`Resolved image link "${linkText}" to: ${resolvedFile.path}`);
        return resolvedFile.path;
      } else {
        console.log(`Could not resolve image link: "${linkText}"`);
      }
      return linkText;
    }
    return imageInput.trim();
  }
  getImageSrc(imagePath) {
    try {
      const adapterPath = this.app.vault.adapter.getResourcePath(imagePath);
      if (adapterPath) {
        return adapterPath;
      }
    } catch (error) {
      console.warn("adapter.getResourcePath failed:", error);
    }
    try {
      const file = this.app.vault.getAbstractFileByPath(imagePath);
      if (file && file instanceof import_obsidian4.TFile) {
        const vaultPath = this.app.vault.getResourcePath(file);
        if (vaultPath) {
          return vaultPath;
        }
      }
    } catch (error) {
      console.warn("vault.getResourcePath failed:", error);
    }
    console.warn(`Using direct path for image: ${imagePath}`);
    return imagePath;
  }
};

// src/contacts-view.ts
var import_obsidian5 = require("obsidian");
var CONTACTS_VIEW_TYPE = "contacts-view";
var ContactsView = class extends import_obsidian5.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.allContacts = [];
    this.filteredContacts = [];
    this.searchQuery = "";
    this.selectedType = "all";
    this.sortMode = "alphabetical";
    this.plugin = plugin;
    this.settings = plugin.settings;
    this.linkResolver = plugin.getLinkResolver();
    this.fileManager = plugin.getFileManager();
  }
  getViewType() {
    return CONTACTS_VIEW_TYPE;
  }
  getDisplayText() {
    return "Contacts";
  }
  getIcon() {
    return "users";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("contacts-view-container");
    if (this.selectedType !== "all" && !this.settings.enabledContactTypes.includes(this.selectedType)) {
      this.selectedType = "all";
    }
    this.linkResolver.invalidateCache();
    await this.loadAllContacts();
    this.renderView();
  }
  async onClose() {
  }
  async loadAllContacts() {
    try {
      const [people, companies, unions, organizations] = await Promise.all([
        this.linkResolver.getAllContactsOfType("People"),
        this.linkResolver.getAllContactsOfType("Company"),
        this.linkResolver.getAllContactsOfType("TradeUnion"),
        this.linkResolver.getAllContactsOfType("Organization")
      ]);
      this.allContacts = [...people, ...companies, ...unions, ...organizations];
      this.filteredContacts = [...this.allContacts];
    } catch (error) {
      console.error("Error loading contacts:", error);
      new import_obsidian5.Notice("Error loading contacts");
    }
  }
  renderView() {
    const container = this.containerEl.children[1];
    container.empty();
    const header = container.createDiv({ cls: "contacts-header" });
    header.createEl("h2", { text: "Contacts Manager", cls: "contacts-title" });
    this.renderSearchAndFilters(header);
    const actionButtons = header.createDiv({ cls: "contacts-action-buttons" });
    if (this.selectedType === "People") {
      this.renderSortDropdown(actionButtons);
    }
    const refreshButton = actionButtons.createEl("button", {
      text: "\u{1F504} Refresh",
      cls: "contacts-refresh-button"
    });
    refreshButton.addEventListener("click", async () => {
      refreshButton.disabled = true;
      refreshButton.textContent = "\u{1F504} Refreshing...";
      this.plugin.forceRefresh();
      await this.refresh();
      refreshButton.disabled = false;
      refreshButton.textContent = "\u{1F504} Refresh";
    });
    const addButton = actionButtons.createEl("button", {
      text: "+ New Contact",
      cls: "contacts-add-button"
    });
    addButton.addEventListener("click", () => {
      const creator = new ContactCreator(
        this.app,
        this.settings,
        this.fileManager
      );
      creator.open();
    });
    const content = container.createDiv({ cls: "contacts-content" });
    this.renderTypeTabs(content);
    this.renderContactsGrid(content);
  }
  renderSearchAndFilters(container) {
    const searchContainer = container.createDiv({ cls: "contacts-search-container" });
    const searchInputWrapper = searchContainer.createDiv({ cls: "contacts-search-input-wrapper" });
    const searchInput = searchInputWrapper.createEl("input", {
      type: "text",
      placeholder: "Search contacts...",
      cls: "contacts-search-input"
    });
    const clearButton = searchInputWrapper.createEl("button", {
      text: "\xD7",
      cls: "contacts-search-clear",
      attr: { "aria-label": "Clear search", "title": "Clear search" }
    });
    clearButton.style.display = "none";
    if (this.searchQuery) {
      searchInput.value = this.searchQuery;
      clearButton.style.display = "block";
    }
    const updateSearch = (value) => {
      this.searchQuery = value;
      clearButton.style.display = value ? "block" : "none";
      this.loadAllContacts().then(() => {
        this.filterContacts();
        this.renderContactsGrid(this.containerEl.querySelector(".contacts-content"));
      });
    };
    searchInput.addEventListener("input", (e) => {
      const value = e.target.value;
      updateSearch(value);
    });
    clearButton.addEventListener("click", () => {
      searchInput.value = "";
      searchInput.focus();
      updateSearch("");
    });
    const resultsCount = searchContainer.createDiv({ cls: "contacts-results-count" });
    resultsCount.textContent = `${this.filteredContacts.length} contacts`;
  }
  renderTypeTabs(container) {
    const existingTabs = container.querySelector(".contacts-tabs");
    if (existingTabs) {
      existingTabs.remove();
    }
    const tabsContainer = container.createDiv({ cls: "contacts-tabs" });
    const allTabs = [
      { type: "all", label: "All", icon: "\u{1F4CB}" },
      { type: "People", label: "People", icon: "\u{1F464}" },
      { type: "Company", label: "Companies", icon: "\u{1F3E2}" },
      { type: "TradeUnion", label: "Trade Unions", icon: "\u{1F91D}" },
      { type: "Organization", label: "Organizations", icon: "\u{1F3DB}\uFE0F" }
    ];
    const tabs = allTabs.filter(
      (tab) => tab.type === "all" || this.settings.enabledContactTypes.includes(tab.type)
    );
    tabs.forEach((tab) => {
      const tabElement = tabsContainer.createDiv({
        cls: `contacts-tab ${this.selectedType === tab.type ? "active" : ""}`,
        text: `${tab.icon} ${tab.label}`
      });
      const count = tab.type === "all" ? this.allContacts.length : this.allContacts.filter((c) => c.contact.type === tab.type).length;
      tabElement.createSpan({ text: ` (${count})`, cls: "tab-count" });
      tabElement.addEventListener("click", () => {
        const tabsContainer2 = this.containerEl.querySelector(".contacts-tabs");
        const currentScrollLeft = tabsContainer2 ? tabsContainer2.scrollLeft : 0;
        this.selectedType = tab.type;
        this.loadAllContacts().then(() => {
          this.filterContacts();
          this.updateTabCounts();
          this.updateActiveTab(true);
          this.renderContactsGrid(this.containerEl.querySelector(".contacts-content"));
          this.renderSortControls();
        });
      });
    });
    this.updateActiveTab(true);
  }
  scrollToActiveTab() {
    setTimeout(() => {
      const tabsContainer = this.containerEl.querySelector(".contacts-tabs");
      const activeTab = this.containerEl.querySelector(".contacts-tab.active");
      if (tabsContainer && activeTab) {
        const containerRect = tabsContainer.getBoundingClientRect();
        const activeRect = activeTab.getBoundingClientRect();
        const scrollLeft = activeTab.offsetLeft - tabsContainer.clientWidth / 2 + activeTab.clientWidth / 2;
        tabsContainer.scrollTo({
          left: scrollLeft,
          behavior: "smooth"
        });
      }
    }, 10);
  }
  updateActiveTab(shouldScroll = false) {
    const tabs = this.containerEl.querySelectorAll(".contacts-tab");
    let hasChanged = false;
    tabs.forEach((tab) => {
      const wasActive = tab.classList.contains("active");
      const tabText = tab.textContent || "";
      let shouldActivate = false;
      if (this.selectedType === "all" && tabText.includes("All")) {
        shouldActivate = true;
      } else if (this.selectedType === "People" && tabText.includes("People")) {
        shouldActivate = true;
      } else if (this.selectedType === "Company" && tabText.includes("Companies")) {
        shouldActivate = true;
      } else if (this.selectedType === "TradeUnion" && tabText.includes("Trade Unions")) {
        shouldActivate = true;
      } else if (this.selectedType === "Organization" && tabText.includes("Organizations")) {
        shouldActivate = true;
      }
      if (wasActive && !shouldActivate) {
        tab.removeClass("active");
        hasChanged = true;
      } else if (!wasActive && shouldActivate) {
        tab.addClass("active");
        hasChanged = true;
      }
    });
    if (hasChanged || shouldScroll) {
      this.scrollToActiveTab();
    }
  }
  updateTabCounts() {
    const tabs = this.containerEl.querySelectorAll(".contacts-tab");
    tabs.forEach((tab) => {
      const tabText = tab.textContent || "";
      let count = 0;
      if (tabText.includes("All")) {
        count = this.allContacts.length;
      } else if (tabText.includes("People")) {
        count = this.allContacts.filter((c) => c.contact.type === "People").length;
      } else if (tabText.includes("Companies")) {
        count = this.allContacts.filter((c) => c.contact.type === "Company").length;
      } else if (tabText.includes("Trade Unions")) {
        count = this.allContacts.filter((c) => c.contact.type === "TradeUnion").length;
      } else if (tabText.includes("Organizations")) {
        count = this.allContacts.filter((c) => c.contact.type === "Organization").length;
      }
      const countSpan = tab.querySelector(".tab-count");
      if (countSpan) {
        countSpan.textContent = ` (${count})`;
      }
    });
  }
  renderSortControls() {
    const actionButtons = this.containerEl.querySelector(".contacts-action-buttons");
    if (actionButtons) {
      const existingSortDropdown = actionButtons.querySelector(".contacts-sort-dropdown");
      if (existingSortDropdown) {
        existingSortDropdown.remove();
      }
      this.renderSortDropdown(actionButtons);
    }
  }
  renderSortDropdown(container) {
    const dropdownContainer = container.createDiv({ cls: "contacts-sort-dropdown" });
    const allSortOptions = [
      { mode: "alphabetical", label: "A-Z", icon: "\u{1F524}" },
      { mode: "company", label: "Company", icon: "\u{1F3E2}" },
      { mode: "union", label: "Union", icon: "\u{1F91D}" },
      { mode: "organization", label: "Organization", icon: "\u{1F3DB}\uFE0F" }
    ];
    const sortOptions = allSortOptions.filter((option) => {
      switch (option.mode) {
        case "alphabetical":
          return true;
        case "company":
          return this.settings.enabledContactTypes.includes("Company");
        case "union":
          return this.settings.enabledContactTypes.includes("TradeUnion");
        case "organization":
          return this.settings.enabledContactTypes.includes("Organization");
        default:
          return true;
      }
    });
    const currentModeAvailable = sortOptions.some((opt) => opt.mode === this.sortMode);
    if (!currentModeAvailable) {
      this.sortMode = "alphabetical";
    }
    const currentOption = sortOptions.find((opt) => opt.mode === this.sortMode) || sortOptions[0];
    const dropdownButton = dropdownContainer.createEl("button", {
      text: `\u{1F4CA} ${currentOption.label}`,
      cls: "contacts-sort-dropdown-button",
      attr: { "aria-haspopup": "true", "aria-expanded": "false" }
    });
    const dropdownMenu = dropdownContainer.createDiv({ cls: "contacts-sort-dropdown-menu" });
    dropdownMenu.style.display = "none";
    sortOptions.forEach((option) => {
      const menuItem = dropdownMenu.createDiv({
        text: `${option.icon} ${option.label}`,
        cls: `contacts-sort-dropdown-item ${this.sortMode === option.mode ? "active" : ""}`
      });
      menuItem.addEventListener("click", () => {
        this.sortMode = option.mode;
        this.filterContacts();
        dropdownMenu.style.display = "none";
        dropdownButton.setAttribute("aria-expanded", "false");
        this.renderView();
      });
    });
    dropdownButton.addEventListener("click", (e) => {
      e.stopPropagation();
      const isOpen = dropdownMenu.style.display === "block";
      dropdownMenu.style.display = isOpen ? "none" : "block";
      dropdownButton.setAttribute("aria-expanded", (!isOpen).toString());
    });
    document.addEventListener("click", () => {
      dropdownMenu.style.display = "none";
      dropdownButton.setAttribute("aria-expanded", "false");
    });
  }
  sortContacts(contacts) {
    contacts.sort((a, b) => {
      const aContact = a.contact;
      const bContact = b.contact;
      if (this.sortMode === "alphabetical") {
        return a.filename.localeCompare(b.filename);
      }
      let aGroupValue = "";
      let bGroupValue = "";
      if (this.sortMode === "company") {
        aGroupValue = this.cleanLinkText(aContact.company || "");
        bGroupValue = this.cleanLinkText(bContact.company || "");
      } else if (this.sortMode === "union") {
        aGroupValue = this.cleanLinkText(aContact.tradeUnion || "");
        bGroupValue = this.cleanLinkText(bContact.tradeUnion || "");
      } else if (this.sortMode === "organization") {
        aGroupValue = this.cleanLinkText(aContact.organization || "");
        bGroupValue = this.cleanLinkText(bContact.organization || "");
      }
      if (!aGroupValue && !bGroupValue) {
        return a.filename.localeCompare(b.filename);
      }
      if (!aGroupValue)
        return 1;
      if (!bGroupValue)
        return -1;
      const groupComparison = aGroupValue.localeCompare(bGroupValue);
      if (groupComparison !== 0) {
        return groupComparison;
      }
      return a.filename.localeCompare(b.filename);
    });
  }
  cleanLinkText(text) {
    const cleaned = text.replace(/^\[\[/, "").replace(/\]\]$/, "").trim();
    return cleaned.includes("|") ? cleaned.split("|")[1] : cleaned;
  }
  getContactTypeCssClass(type) {
    switch (type) {
      case "TradeUnion":
        return "union";
      case "People":
        return "people";
      case "Company":
        return "company";
      case "Organization":
        return "organization";
      default:
        return type.toLowerCase();
    }
  }
  renderContactsGrid(container) {
    const existingGrid = container.querySelector(".contacts-grid");
    if (existingGrid) {
      existingGrid.remove();
    }
    const gridContainer = container.createDiv({ cls: "contacts-grid" });
    if (this.filteredContacts.length === 0) {
      const emptyState = gridContainer.createDiv({ cls: "contacts-empty-state" });
      emptyState.createEl("div", { text: "\u{1F4DD}", cls: "empty-icon" });
      emptyState.createEl("h3", { text: "No contacts found" });
      emptyState.createEl("p", { text: "Try adjusting your search or create a new contact." });
      return;
    }
    this.filteredContacts.forEach((contactResult) => {
      const card = this.createContactGridCard(contactResult);
      gridContainer.appendChild(card);
    });
    const resultsCount = this.containerEl.querySelector(".contacts-results-count");
    if (resultsCount) {
      resultsCount.textContent = `${this.filteredContacts.length} contacts`;
    }
  }
  createContactGridCard(contactResult) {
    const contact = contactResult.contact;
    const card = createDiv({ cls: `contact-grid-card ${this.getContactTypeCssClass(contact.type)}` });
    const cardHeader = card.createDiv({ cls: "card-header" });
    const imageContainer = cardHeader.createDiv({ cls: "card-image-container" });
    const imageInput = contact.coverImage;
    const imagePath = this.getImagePath(imageInput);
    if (imagePath) {
      const img = imageContainer.createEl("img", {
        cls: "card-image",
        attr: { src: this.getImageSrc(imagePath) }
      });
      img.onerror = () => {
        imageContainer.innerHTML = '<div class="card-image-placeholder">' + this.getTypeIcon(contact.type) + "</div>";
      };
    } else {
      imageContainer.innerHTML = '<div class="card-image-placeholder">' + this.getTypeIcon(contact.type) + "</div>";
    }
    if (contact.type === "People") {
      const orgName = contact.tradeUnion || contact.company || contact.organization;
      if (orgName) {
        const overlay = imageContainer.createDiv({ cls: "card-org-logo-overlay" });
        this.loadOrgLogoForOverlay(overlay, orgName);
      }
    }
    const infoContainer = cardHeader.createDiv({ cls: "card-info" });
    const nameElement = infoContainer.createEl("h3", {
      text: contactResult.filename,
      cls: "card-name"
    });
    const typeElement = infoContainer.createEl("div", {
      text: contact.type,
      cls: "card-type"
    });
    const fieldsContainer = infoContainer.createDiv({ cls: "card-affiliations" });
    if (contact.type === "People") {
      const peopleContact = contact;
      if (peopleContact.tradeUnion) {
        const cleanTradeUnion = peopleContact.tradeUnion.replace(/^\[\[/, "").replace(/\]\]$/, "");
        const displayText = cleanTradeUnion.includes("|") ? cleanTradeUnion.split("|")[1] : cleanTradeUnion;
        fieldsContainer.createDiv({
          text: `\u{1F91D} ${displayText}`,
          cls: "card-affiliation"
        });
      }
      if (peopleContact.company) {
        const cleanCompany = peopleContact.company.replace(/^\[\[/, "").replace(/\]\]$/, "");
        const displayText = cleanCompany.includes("|") ? cleanCompany.split("|")[1] : cleanCompany;
        fieldsContainer.createDiv({
          text: `\u{1F3E2} ${displayText}`,
          cls: "card-affiliation"
        });
      }
      if (peopleContact.organization) {
        const cleanOrganization = peopleContact.organization.replace(/^\[\[/, "").replace(/\]\]$/, "");
        const displayText = cleanOrganization.includes("|") ? cleanOrganization.split("|")[1] : cleanOrganization;
        fieldsContainer.createDiv({
          text: `\u{1F3DB}\uFE0F ${displayText}`,
          cls: "card-affiliation"
        });
      }
      if (peopleContact.role) {
        fieldsContainer.createDiv({
          text: `\u{1F4BC} ${peopleContact.role}`,
          cls: "card-affiliation"
        });
      }
    } else if (contact.type === "Company") {
      const companyContact = contact;
      if (companyContact.ActiveProjects && companyContact.ActiveProjects.length > 0) {
        fieldsContainer.createDiv({
          text: `\u{1F680} ${companyContact.ActiveProjects.length} active project${companyContact.ActiveProjects.length !== 1 ? "s" : ""}`,
          cls: "card-affiliation"
        });
      }
      if (companyContact.website) {
        fieldsContainer.createDiv({
          text: `\u{1F310} ${companyContact.website}`,
          cls: "card-affiliation"
        });
      }
    } else if (contact.type === "TradeUnion") {
      const tradeUnionContact = contact;
      if (contact.country && contact.country.length > 0) {
        fieldsContainer.createDiv({
          text: `\u{1F30D} ${contact.country.slice(0, 2).join(", ")}${contact.country.length > 2 ? "..." : ""}`,
          cls: "card-affiliation"
        });
      }
      if (tradeUnionContact.ActiveProjects && tradeUnionContact.ActiveProjects.length > 0) {
        fieldsContainer.createDiv({
          text: `\u{1F680} ${tradeUnionContact.ActiveProjects.length} active project${tradeUnionContact.ActiveProjects.length !== 1 ? "s" : ""}`,
          cls: "card-affiliation"
        });
      }
    } else if (contact.type === "Organization") {
      if (contact.country && contact.country.length > 0) {
        fieldsContainer.createDiv({
          text: `\u{1F30D} ${contact.country.slice(0, 2).join(", ")}${contact.country.length > 2 ? "..." : ""}`,
          cls: "card-affiliation"
        });
      }
    }
    if (fieldsContainer.children.length === 0) {
      fieldsContainer.remove();
    }
    if (contact.tags && contact.tags.length > 0) {
      const tagsContainer = infoContainer.createDiv({ cls: "card-tags" });
      contact.tags.forEach((tag) => {
        tagsContainer.createSpan({ text: `#${tag}`, cls: "card-tag" });
      });
    }
    if (contact.description) {
      const descriptionText = contact.description.length > 500 ? contact.description.substring(0, 500) + "..." : contact.description;
      const summary = infoContainer.createDiv({
        text: descriptionText,
        cls: "card-summary"
      });
    }
    card.addEventListener("click", (e) => {
      if (e.button === 2)
        return;
      this.app.workspace.openLinkText(contactResult.path, "", false);
    });
    return card;
  }
  addQuickInfo(container, contact) {
    switch (contact.type) {
      case "People":
        if (contact.email) {
          const emailInfo = container.createDiv({ cls: "quick-info-item" });
          emailInfo.createSpan({ text: "\u2709\uFE0F", cls: "quick-info-icon" });
          emailInfo.createSpan({ text: contact.email, cls: "quick-info-text" });
        }
        if (contact.phone) {
          const phoneInfo = container.createDiv({ cls: "quick-info-item" });
          phoneInfo.createSpan({ text: "\u{1F4F1}", cls: "quick-info-icon" });
          phoneInfo.createSpan({ text: contact.phone, cls: "quick-info-text" });
        }
        break;
      case "Company":
        if (contact.Management && contact.Management.length > 0) {
          const mgmtInfo = container.createDiv({ cls: "quick-info-item" });
          mgmtInfo.createSpan({ text: "\u{1F454}", cls: "quick-info-icon" });
          mgmtInfo.createSpan({ text: `Management: ${contact.Management.slice(0, 2).join(", ")}${contact.Management.length > 2 ? "..." : ""}`, cls: "quick-info-text" });
        }
        break;
      case "TradeUnion":
      case "Organization":
        if (contact.ActiveProjects && contact.ActiveProjects.length > 0) {
          const projectsInfo = container.createDiv({ cls: "quick-info-item" });
          projectsInfo.createSpan({ text: "\u{1F680}", cls: "quick-info-icon" });
          projectsInfo.createSpan({ text: `${contact.ActiveProjects.length} active project${contact.ActiveProjects.length !== 1 ? "s" : ""}`, cls: "quick-info-text" });
        }
        break;
    }
    if (contact.Country && contact.Country.length > 0) {
      const countryInfo = container.createDiv({ cls: "quick-info-item" });
      countryInfo.createSpan({ text: "\u{1F30D}", cls: "quick-info-icon" });
      countryInfo.createSpan({
        text: contact.country.slice(0, 2).join(", ") + (contact.country.length > 2 ? "..." : ""),
        cls: "quick-info-text"
      });
    }
  }
  getTypeIcon(type) {
    switch (type) {
      case "People":
        return "\u{1F464}";
      case "Company":
        return "\u{1F3E2}";
      case "TradeUnion":
        return "\u{1F91D}";
      case "Organization":
        return "\u{1F3DB}\uFE0F";
      default:
        return "\u{1F4C4}";
    }
  }
  validateSortMode() {
    let isValid = false;
    switch (this.sortMode) {
      case "alphabetical":
        isValid = true;
        break;
      case "company":
        isValid = this.settings.enabledContactTypes.includes("Company");
        break;
      case "union":
        isValid = this.settings.enabledContactTypes.includes("TradeUnion");
        break;
      case "organization":
        isValid = this.settings.enabledContactTypes.includes("Organization");
        break;
      default:
        isValid = false;
    }
    if (!isValid) {
      this.sortMode = "alphabetical";
    }
  }
  updateSettings(settings) {
    this.settings = settings;
    if (this.selectedType !== "all" && !this.settings.enabledContactTypes.includes(this.selectedType)) {
      this.selectedType = "all";
    }
    this.validateSortMode();
    this.renderView();
  }
  filterContacts() {
    let filtered = this.allContacts;
    if (this.selectedType !== "all") {
      filtered = filtered.filter((contact) => contact.contact.type === this.selectedType);
    }
    if (this.searchQuery.trim()) {
      const query = this.searchQuery.toLowerCase();
      filtered = filtered.filter((contact) => {
        const c = contact.contact;
        const searchFields = [
          contact.filename,
          c.description || "",
          c.role || "",
          c.email || "",
          c.phone || "",
          c.LinkedIn || "",
          c.website || "",
          c.tradeUnion || "",
          c.company || "",
          c.organization || "",
          ...c.tags || [],
          ...c.country || [],
          ...c.ActiveProjects || [],
          ...c.Management || [],
          ...c.ContactInfo || [],
          ...c.collections || [],
          ...c.aliases || []
        ];
        const searchText = searchFields.filter((field) => field && field.toString().trim()).map((field) => field.toString().replace(/^\[\[/, "").replace(/\]\]$/, "")).join(" ").toLowerCase();
        return searchText.includes(query);
      });
    }
    this.sortContacts(filtered);
    this.filteredContacts = filtered;
  }
  async refresh() {
    this.settings = this.plugin.settings;
    if (this.selectedType !== "all" && !this.settings.enabledContactTypes.includes(this.selectedType)) {
      this.selectedType = "all";
    }
    this.validateSortMode();
    this.linkResolver.invalidateCache();
    await this.loadAllContacts();
    this.filterContacts();
    this.renderView();
  }
  async loadOrgLogoForOverlay(container, orgName) {
    try {
      const cleanName = orgName.replace(/^\[\[/, "").replace(/\]\]$/, "");
      const orgFile = this.app.vault.getAbstractFileByPath(cleanName + ".md") || this.app.metadataCache.getFirstLinkpathDest(cleanName, "");
      if (orgFile) {
        const orgContact = await this.linkResolver.parseContactFile(orgFile);
        if ((orgContact == null ? void 0 : orgContact.contact) && "coverImage" in orgContact.contact && orgContact.contact.coverImage) {
          const logoPath = this.getImagePath(orgContact.contact.coverImage);
          if (logoPath) {
            const img = container.createEl("img", {
              attr: { src: this.getImageSrc(logoPath) }
            });
            img.onerror = () => {
              container.innerHTML = "\u{1F3E2}";
            };
            return;
          }
        }
      }
    } catch (error) {
      console.warn("Could not load organization logo for overlay:", error);
    }
    container.innerHTML = "\u{1F3E2}";
  }
  async openContactEditor(contactResult) {
    const file = this.app.vault.getAbstractFileByPath(contactResult.path);
    if (file && file.path) {
      await this.app.workspace.openLinkText(contactResult.path, "", false);
    } else {
      new import_obsidian5.Notice("Contact file not found");
    }
  }
  async confirmDeleteContact(contactResult) {
    const contactName = contactResult.filename;
    const confirmed = await new Promise((resolve) => {
      const modal = new import_obsidian5.Modal(this.app);
      modal.titleEl.setText("Delete Contact");
      modal.contentEl.empty();
      modal.contentEl.createEl("p", {
        text: `Are you sure you want to delete "${contactName}"?`
      });
      modal.contentEl.createEl("p", {
        text: "This action cannot be undone.",
        cls: "mod-warning"
      });
      const buttonContainer = modal.contentEl.createDiv({ cls: "modal-button-container" });
      const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
      cancelBtn.addEventListener("click", () => {
        modal.close();
        resolve(false);
      });
      const deleteBtn = buttonContainer.createEl("button", {
        text: "Delete",
        cls: "mod-warning"
      });
      deleteBtn.addEventListener("click", () => {
        modal.close();
        resolve(true);
      });
      modal.open();
    });
    if (confirmed) {
      try {
        const file = this.app.vault.getAbstractFileByPath(contactResult.path);
        if (file) {
          await this.app.vault.delete(file);
          new import_obsidian5.Notice(`Contact "${contactName}" deleted successfully`);
          await this.refresh();
        }
      } catch (error) {
        console.error("Error deleting contact:", error);
        new import_obsidian5.Notice("Error deleting contact");
      }
    }
  }
  extractLinkText(value) {
    const linkMatch = value.match(/\[\[([^\]]+)\]\]/);
    if (linkMatch) {
      const linkContent = linkMatch[1];
      return linkContent.includes("|") ? linkContent.split("|")[0].trim() : linkContent;
    }
    return value;
  }
  getImagePath(imageInput) {
    if (!(imageInput == null ? void 0 : imageInput.trim()))
      return null;
    if (imageInput.includes("[[") && imageInput.includes("]]")) {
      const linkText = this.extractLinkText(imageInput);
      const resolvedFile = this.app.metadataCache.getFirstLinkpathDest(linkText, "");
      if (resolvedFile) {
        console.log(`Resolved image link "${linkText}" to: ${resolvedFile.path}`);
        return resolvedFile.path;
      } else {
        console.log(`Could not resolve image link: "${linkText}"`);
      }
      return linkText;
    }
    return imageInput.trim();
  }
  getImageSrc(imagePath) {
    try {
      const adapterPath = this.app.vault.adapter.getResourcePath(imagePath);
      if (adapterPath) {
        return adapterPath;
      }
    } catch (error) {
      console.warn("adapter.getResourcePath failed:", error);
    }
    try {
      const file = this.app.vault.getAbstractFileByPath(imagePath);
      if (file && file instanceof import_obsidian5.TFile) {
        const vaultPath = this.app.vault.getResourcePath(file);
        if (vaultPath) {
          return vaultPath;
        }
      }
    } catch (error) {
      console.warn("vault.getResourcePath failed:", error);
    }
    console.warn(`Using direct path for image: ${imagePath}`);
    return imagePath;
  }
};

// main.ts
var ContactCardsPlugin = class extends import_obsidian6.Plugin {
  constructor() {
    super(...arguments);
    this.lastRefreshTime = 0;
    this.refreshCooldown = 3e4;
  }
  // 30 seconds
  async onload() {
    await this.loadSettings();
    this.linkResolver = new LinkResolver(this.app, this.settings);
    this.fileManager = new FileManager(this.app, this.settings);
    this.contactCardView = new ContactCardView(this.app, this.settings, this.linkResolver);
    this.registerView(
      CONTACTS_VIEW_TYPE,
      (leaf) => new ContactsView(leaf, this)
    );
    this.registerEvents();
    this.addCommands();
    this.addRibbonButton();
    this.setupMarkdownPostProcessor();
    this.addSettingTab(new ContactCardsSettingTab(this.app, this));
    console.log("ContactManager Plugin loaded");
  }
  onunload() {
    console.log("Contact Cards Plugin unloaded");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    if (this.linkResolver) {
      this.linkResolver.updateSettings(this.settings);
    }
    if (this.fileManager) {
      this.fileManager.updateSettings(this.settings);
    }
    if (this.contactCardView) {
      this.contactCardView.updateSettings(this.settings);
    }
    this.refreshAllContactsViews();
  }
  refreshAllContactsViews() {
    const contactsViews = this.app.workspace.getLeavesOfType(CONTACTS_VIEW_TYPE);
    contactsViews.forEach((leaf) => {
      const view = leaf.view;
      if (view && view.refresh) {
        view.refresh();
      }
    });
  }
  refreshContactCardsInOpenNotes() {
    const markdownViews = this.app.workspace.getLeavesOfType("markdown");
    markdownViews.forEach((leaf) => {
      const view = leaf.view;
      if (view && view.file && this.isContactFile(view.file)) {
        if (view.previewMode) {
          view.previewMode.rerender(true);
        }
      }
    });
  }
  registerEvents() {
    this.registerEvent(
      this.app.vault.on("create", this.onFileCreate.bind(this))
    );
    this.registerEvent(
      this.app.vault.on("rename", this.onFileRename.bind(this))
    );
    this.registerEvent(
      this.app.vault.on("delete", this.onFileDelete.bind(this))
    );
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", this.onActiveLeafChange.bind(this))
    );
  }
  addCommands() {
    this.addCommand({
      id: "open-contacts-view",
      name: "Open Contacts View",
      callback: () => {
        this.openContactsView();
      }
    });
    this.addCommand({
      id: "create-contact",
      name: "Create New Contact",
      callback: () => {
        this.openContactCreator();
      }
    });
    this.addCommand({
      id: "create-people-contact",
      name: "Create People Contact",
      callback: () => {
        this.openContactCreator("People");
      }
    });
    this.addCommand({
      id: "create-company-contact",
      name: "Create Company Contact",
      callback: () => {
        this.openContactCreator("Company");
      }
    });
    this.addCommand({
      id: "create-trade-union-contact",
      name: "Create Trade Union Contact",
      callback: () => {
        this.openContactCreator("TradeUnion");
      }
    });
    this.addCommand({
      id: "create-organization-contact",
      name: "Create Organization Contact",
      callback: () => {
        this.openContactCreator("Organization");
      }
    });
    this.addCommand({
      id: "refresh-contact-links",
      name: "Refresh Contact Links",
      callback: async () => {
        await this.refreshAllContactLinks();
      }
    });
    this.addCommand({
      id: "refresh-current-contact-links",
      name: "Refresh Current Contact Links",
      checkCallback: (checking) => {
        const activeFile = this.app.workspace.getActiveFile();
        if (activeFile && this.isContactFile(activeFile)) {
          if (!checking) {
            this.linkResolver.refreshDynamicLinks(activeFile.path);
            new import_obsidian6.Notice("Contact links refreshed!");
          }
          return true;
        }
        return false;
      }
    });
  }
  addRibbonButton() {
    const ribbonIconEl = this.addRibbonIcon("users", "Open Contacts", (evt) => {
      this.openContactsView();
    });
    ribbonIconEl.addClass("contact-cards-ribbon-icon");
  }
  async openContactsView() {
    const existing = this.app.workspace.getLeavesOfType(CONTACTS_VIEW_TYPE);
    if (existing.length > 0) {
      this.app.workspace.revealLeaf(existing[0]);
      return;
    }
    const leaf = this.app.workspace.getRightLeaf(false);
    await leaf.setViewState({
      type: CONTACTS_VIEW_TYPE,
      active: true
    });
    this.app.workspace.revealLeaf(leaf);
  }
  setupMarkdownPostProcessor() {
    this.registerMarkdownPostProcessor(async (element, context) => {
      await this.processContactCard(element, context);
    });
  }
  async processContactCard(element, context) {
    if (!context.sourcePath)
      return;
    const file = this.app.vault.getAbstractFileByPath(context.sourcePath);
    if (!file || !this.isContactFile(file))
      return;
    try {
      const contactResult = await this.linkResolver.parseContactFile(file);
      if (!contactResult)
        return;
      await this.contactCardView.renderCard(contactResult.contact, element, file.path);
    } catch (error) {
      console.error("Error processing contact card:", error);
    }
  }
  openContactCreator(preselectedType) {
    const creator = new ContactCreator(
      this.app,
      this.settings,
      this.fileManager,
      preselectedType
    );
    creator.open();
  }
  async onFileOpen(file) {
    if (!file || !this.isContactFile(file))
      return;
    try {
      await this.linkResolver.refreshDynamicLinks(file.path);
    } catch (error) {
      console.error("Error refreshing links on file open:", error);
    }
  }
  async onFileCreate(file) {
    if (!this.isContactFile(file))
      return;
    try {
      this.linkResolver.invalidateFileCache(file.path);
    } catch (error) {
      console.error("Error handling file creation:", error);
    }
  }
  async onActiveLeafChange() {
    try {
      if (this.shouldRefresh()) {
        this.refreshContactCardsInOpenNotes();
        this.updateLastRefreshTime();
      }
    } catch (error) {
      console.error("Error handling leaf change:", error);
    }
  }
  async onFileRename(file, oldPath) {
    if (!this.isContactFile(file))
      return;
    try {
      this.linkResolver.invalidateCache();
      await this.refreshAllContactLinks();
    } catch (error) {
      console.error("Error handling file rename:", error);
    }
  }
  async onFileDelete(file) {
    if (!this.isContactFile(file))
      return;
    try {
      this.linkResolver.invalidateCache();
      await this.refreshAllContactLinks();
      this.refreshAllContactsViews();
    } catch (error) {
      console.error("Error handling file deletion:", error);
    }
  }
  shouldRefresh() {
    const now = Date.now();
    return now - this.lastRefreshTime >= this.refreshCooldown;
  }
  updateLastRefreshTime() {
    this.lastRefreshTime = Date.now();
  }
  forceRefresh() {
    this.refreshContactCardsInOpenNotes();
    this.refreshAllContactsViews();
    this.updateLastRefreshTime();
  }
  async refreshAllContactLinks() {
    try {
      const allContacts = [
        ...await this.linkResolver.getAllContactsOfType("People"),
        ...await this.linkResolver.getAllContactsOfType("Company"),
        ...await this.linkResolver.getAllContactsOfType("TradeUnion"),
        ...await this.linkResolver.getAllContactsOfType("Organization")
      ];
      for (const contact of allContacts) {
        await this.linkResolver.refreshDynamicLinks(contact.path);
      }
      new import_obsidian6.Notice(`Refreshed links for ${allContacts.length} contacts`);
    } catch (error) {
      console.error("Error refreshing all contact links:", error);
      new import_obsidian6.Notice("Error refreshing contact links");
    }
  }
  isContactFile(file) {
    if (!file || file.extension !== "md")
      return false;
    const allFolders = [
      ...this.settings.peopleFolders,
      ...this.settings.companyFolders,
      ...this.settings.tradeUnionFolders,
      ...this.settings.organizationFolders
    ];
    return allFolders.some(
      (folder) => file.path.startsWith(folder + "/") || file.path === folder
    );
  }
  async isContactFileByContent(file) {
    try {
      const metadata = this.app.metadataCache.getFileCache(file);
      const frontmatter = metadata == null ? void 0 : metadata.frontmatter;
      if (!frontmatter)
        return false;
      const contactType = frontmatter.type;
      return contactType && ["People", "Company", "TradeUnion", "Organization"].includes(contactType);
    } catch (error) {
      return false;
    }
  }
  async createContactFromTemplate(name, type, folder, data = {}) {
    return await this.fileManager.createContactFile(name, type, folder, data);
  }
  async getContactsInFolder(folderPath) {
    const contacts = await this.linkResolver.getContactsInFolder(folderPath);
    return contacts.map((result) => result.contact);
  }
  async getContactByPath(filePath) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!file)
      return null;
    const result = await this.linkResolver.parseContactFile(file);
    return result ? result.contact : null;
  }
  getLinkResolver() {
    return this.linkResolver;
  }
  getFileManager() {
    return this.fileManager;
  }
  getContactCardView() {
    return this.contactCardView;
  }
};
